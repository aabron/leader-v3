{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.anyTypeAnnotation = anyTypeAnnotation;\nexports.argumentPlaceholder = argumentPlaceholder;\nexports.arrayExpression = arrayExpression;\nexports.arrayPattern = arrayPattern;\nexports.arrayTypeAnnotation = arrayTypeAnnotation;\nexports.arrowFunctionExpression = arrowFunctionExpression;\nexports.assignmentExpression = assignmentExpression;\nexports.assignmentPattern = assignmentPattern;\nexports.awaitExpression = awaitExpression;\nexports.bigIntLiteral = bigIntLiteral;\nexports.binaryExpression = binaryExpression;\nexports.bindExpression = bindExpression;\nexports.blockStatement = blockStatement;\nexports.booleanLiteral = booleanLiteral;\nexports.booleanLiteralTypeAnnotation = booleanLiteralTypeAnnotation;\nexports.booleanTypeAnnotation = booleanTypeAnnotation;\nexports.breakStatement = breakStatement;\nexports.callExpression = callExpression;\nexports.catchClause = catchClause;\nexports.classAccessorProperty = classAccessorProperty;\nexports.classBody = classBody;\nexports.classDeclaration = classDeclaration;\nexports.classExpression = classExpression;\nexports.classImplements = classImplements;\nexports.classMethod = classMethod;\nexports.classPrivateMethod = classPrivateMethod;\nexports.classPrivateProperty = classPrivateProperty;\nexports.classProperty = classProperty;\nexports.conditionalExpression = conditionalExpression;\nexports.continueStatement = continueStatement;\nexports.debuggerStatement = debuggerStatement;\nexports.decimalLiteral = decimalLiteral;\nexports.declareClass = declareClass;\nexports.declareExportAllDeclaration = declareExportAllDeclaration;\nexports.declareExportDeclaration = declareExportDeclaration;\nexports.declareFunction = declareFunction;\nexports.declareInterface = declareInterface;\nexports.declareModule = declareModule;\nexports.declareModuleExports = declareModuleExports;\nexports.declareOpaqueType = declareOpaqueType;\nexports.declareTypeAlias = declareTypeAlias;\nexports.declareVariable = declareVariable;\nexports.declaredPredicate = declaredPredicate;\nexports.decorator = decorator;\nexports.directive = directive;\nexports.directiveLiteral = directiveLiteral;\nexports.doExpression = doExpression;\nexports.doWhileStatement = doWhileStatement;\nexports.emptyStatement = emptyStatement;\nexports.emptyTypeAnnotation = emptyTypeAnnotation;\nexports.enumBooleanBody = enumBooleanBody;\nexports.enumBooleanMember = enumBooleanMember;\nexports.enumDeclaration = enumDeclaration;\nexports.enumDefaultedMember = enumDefaultedMember;\nexports.enumNumberBody = enumNumberBody;\nexports.enumNumberMember = enumNumberMember;\nexports.enumStringBody = enumStringBody;\nexports.enumStringMember = enumStringMember;\nexports.enumSymbolBody = enumSymbolBody;\nexports.existsTypeAnnotation = existsTypeAnnotation;\nexports.exportAllDeclaration = exportAllDeclaration;\nexports.exportDefaultDeclaration = exportDefaultDeclaration;\nexports.exportDefaultSpecifier = exportDefaultSpecifier;\nexports.exportNamedDeclaration = exportNamedDeclaration;\nexports.exportNamespaceSpecifier = exportNamespaceSpecifier;\nexports.exportSpecifier = exportSpecifier;\nexports.expressionStatement = expressionStatement;\nexports.file = file;\nexports.forInStatement = forInStatement;\nexports.forOfStatement = forOfStatement;\nexports.forStatement = forStatement;\nexports.functionDeclaration = functionDeclaration;\nexports.functionExpression = functionExpression;\nexports.functionTypeAnnotation = functionTypeAnnotation;\nexports.functionTypeParam = functionTypeParam;\nexports.genericTypeAnnotation = genericTypeAnnotation;\nexports.identifier = identifier;\nexports.ifStatement = ifStatement;\nexports.import = _import;\nexports.importAttribute = importAttribute;\nexports.importDeclaration = importDeclaration;\nexports.importDefaultSpecifier = importDefaultSpecifier;\nexports.importNamespaceSpecifier = importNamespaceSpecifier;\nexports.importSpecifier = importSpecifier;\nexports.indexedAccessType = indexedAccessType;\nexports.inferredPredicate = inferredPredicate;\nexports.interfaceDeclaration = interfaceDeclaration;\nexports.interfaceExtends = interfaceExtends;\nexports.interfaceTypeAnnotation = interfaceTypeAnnotation;\nexports.interpreterDirective = interpreterDirective;\nexports.intersectionTypeAnnotation = intersectionTypeAnnotation;\nexports.jSXAttribute = exports.jsxAttribute = jsxAttribute;\nexports.jSXClosingElement = exports.jsxClosingElement = jsxClosingElement;\nexports.jSXClosingFragment = exports.jsxClosingFragment = jsxClosingFragment;\nexports.jSXElement = exports.jsxElement = jsxElement;\nexports.jSXEmptyExpression = exports.jsxEmptyExpression = jsxEmptyExpression;\nexports.jSXExpressionContainer = exports.jsxExpressionContainer = jsxExpressionContainer;\nexports.jSXFragment = exports.jsxFragment = jsxFragment;\nexports.jSXIdentifier = exports.jsxIdentifier = jsxIdentifier;\nexports.jSXMemberExpression = exports.jsxMemberExpression = jsxMemberExpression;\nexports.jSXNamespacedName = exports.jsxNamespacedName = jsxNamespacedName;\nexports.jSXOpeningElement = exports.jsxOpeningElement = jsxOpeningElement;\nexports.jSXOpeningFragment = exports.jsxOpeningFragment = jsxOpeningFragment;\nexports.jSXSpreadAttribute = exports.jsxSpreadAttribute = jsxSpreadAttribute;\nexports.jSXSpreadChild = exports.jsxSpreadChild = jsxSpreadChild;\nexports.jSXText = exports.jsxText = jsxText;\nexports.labeledStatement = labeledStatement;\nexports.logicalExpression = logicalExpression;\nexports.memberExpression = memberExpression;\nexports.metaProperty = metaProperty;\nexports.mixedTypeAnnotation = mixedTypeAnnotation;\nexports.moduleExpression = moduleExpression;\nexports.newExpression = newExpression;\nexports.noop = noop;\nexports.nullLiteral = nullLiteral;\nexports.nullLiteralTypeAnnotation = nullLiteralTypeAnnotation;\nexports.nullableTypeAnnotation = nullableTypeAnnotation;\nexports.numberLiteral = NumberLiteral;\nexports.numberLiteralTypeAnnotation = numberLiteralTypeAnnotation;\nexports.numberTypeAnnotation = numberTypeAnnotation;\nexports.numericLiteral = numericLiteral;\nexports.objectExpression = objectExpression;\nexports.objectMethod = objectMethod;\nexports.objectPattern = objectPattern;\nexports.objectProperty = objectProperty;\nexports.objectTypeAnnotation = objectTypeAnnotation;\nexports.objectTypeCallProperty = objectTypeCallProperty;\nexports.objectTypeIndexer = objectTypeIndexer;\nexports.objectTypeInternalSlot = objectTypeInternalSlot;\nexports.objectTypeProperty = objectTypeProperty;\nexports.objectTypeSpreadProperty = objectTypeSpreadProperty;\nexports.opaqueType = opaqueType;\nexports.optionalCallExpression = optionalCallExpression;\nexports.optionalIndexedAccessType = optionalIndexedAccessType;\nexports.optionalMemberExpression = optionalMemberExpression;\nexports.parenthesizedExpression = parenthesizedExpression;\nexports.pipelineBareFunction = pipelineBareFunction;\nexports.pipelinePrimaryTopicReference = pipelinePrimaryTopicReference;\nexports.pipelineTopicExpression = pipelineTopicExpression;\nexports.placeholder = placeholder;\nexports.privateName = privateName;\nexports.program = program;\nexports.qualifiedTypeIdentifier = qualifiedTypeIdentifier;\nexports.recordExpression = recordExpression;\nexports.regExpLiteral = regExpLiteral;\nexports.regexLiteral = RegexLiteral;\nexports.restElement = restElement;\nexports.restProperty = RestProperty;\nexports.returnStatement = returnStatement;\nexports.sequenceExpression = sequenceExpression;\nexports.spreadElement = spreadElement;\nexports.spreadProperty = SpreadProperty;\nexports.staticBlock = staticBlock;\nexports.stringLiteral = stringLiteral;\nexports.stringLiteralTypeAnnotation = stringLiteralTypeAnnotation;\nexports.stringTypeAnnotation = stringTypeAnnotation;\nexports.super = _super;\nexports.switchCase = switchCase;\nexports.switchStatement = switchStatement;\nexports.symbolTypeAnnotation = symbolTypeAnnotation;\nexports.taggedTemplateExpression = taggedTemplateExpression;\nexports.templateElement = templateElement;\nexports.templateLiteral = templateLiteral;\nexports.thisExpression = thisExpression;\nexports.thisTypeAnnotation = thisTypeAnnotation;\nexports.throwStatement = throwStatement;\nexports.topicReference = topicReference;\nexports.tryStatement = tryStatement;\nexports.tSAnyKeyword = exports.tsAnyKeyword = tsAnyKeyword;\nexports.tSArrayType = exports.tsArrayType = tsArrayType;\nexports.tSAsExpression = exports.tsAsExpression = tsAsExpression;\nexports.tSBigIntKeyword = exports.tsBigIntKeyword = tsBigIntKeyword;\nexports.tSBooleanKeyword = exports.tsBooleanKeyword = tsBooleanKeyword;\nexports.tSCallSignatureDeclaration = exports.tsCallSignatureDeclaration = tsCallSignatureDeclaration;\nexports.tSConditionalType = exports.tsConditionalType = tsConditionalType;\nexports.tSConstructSignatureDeclaration = exports.tsConstructSignatureDeclaration = tsConstructSignatureDeclaration;\nexports.tSConstructorType = exports.tsConstructorType = tsConstructorType;\nexports.tSDeclareFunction = exports.tsDeclareFunction = tsDeclareFunction;\nexports.tSDeclareMethod = exports.tsDeclareMethod = tsDeclareMethod;\nexports.tSEnumDeclaration = exports.tsEnumDeclaration = tsEnumDeclaration;\nexports.tSEnumMember = exports.tsEnumMember = tsEnumMember;\nexports.tSExportAssignment = exports.tsExportAssignment = tsExportAssignment;\nexports.tSExpressionWithTypeArguments = exports.tsExpressionWithTypeArguments = tsExpressionWithTypeArguments;\nexports.tSExternalModuleReference = exports.tsExternalModuleReference = tsExternalModuleReference;\nexports.tSFunctionType = exports.tsFunctionType = tsFunctionType;\nexports.tSImportEqualsDeclaration = exports.tsImportEqualsDeclaration = tsImportEqualsDeclaration;\nexports.tSImportType = exports.tsImportType = tsImportType;\nexports.tSIndexSignature = exports.tsIndexSignature = tsIndexSignature;\nexports.tSIndexedAccessType = exports.tsIndexedAccessType = tsIndexedAccessType;\nexports.tSInferType = exports.tsInferType = tsInferType;\nexports.tSInstantiationExpression = exports.tsInstantiationExpression = tsInstantiationExpression;\nexports.tSInterfaceBody = exports.tsInterfaceBody = tsInterfaceBody;\nexports.tSInterfaceDeclaration = exports.tsInterfaceDeclaration = tsInterfaceDeclaration;\nexports.tSIntersectionType = exports.tsIntersectionType = tsIntersectionType;\nexports.tSIntrinsicKeyword = exports.tsIntrinsicKeyword = tsIntrinsicKeyword;\nexports.tSLiteralType = exports.tsLiteralType = tsLiteralType;\nexports.tSMappedType = exports.tsMappedType = tsMappedType;\nexports.tSMethodSignature = exports.tsMethodSignature = tsMethodSignature;\nexports.tSModuleBlock = exports.tsModuleBlock = tsModuleBlock;\nexports.tSModuleDeclaration = exports.tsModuleDeclaration = tsModuleDeclaration;\nexports.tSNamedTupleMember = exports.tsNamedTupleMember = tsNamedTupleMember;\nexports.tSNamespaceExportDeclaration = exports.tsNamespaceExportDeclaration = tsNamespaceExportDeclaration;\nexports.tSNeverKeyword = exports.tsNeverKeyword = tsNeverKeyword;\nexports.tSNonNullExpression = exports.tsNonNullExpression = tsNonNullExpression;\nexports.tSNullKeyword = exports.tsNullKeyword = tsNullKeyword;\nexports.tSNumberKeyword = exports.tsNumberKeyword = tsNumberKeyword;\nexports.tSObjectKeyword = exports.tsObjectKeyword = tsObjectKeyword;\nexports.tSOptionalType = exports.tsOptionalType = tsOptionalType;\nexports.tSParameterProperty = exports.tsParameterProperty = tsParameterProperty;\nexports.tSParenthesizedType = exports.tsParenthesizedType = tsParenthesizedType;\nexports.tSPropertySignature = exports.tsPropertySignature = tsPropertySignature;\nexports.tSQualifiedName = exports.tsQualifiedName = tsQualifiedName;\nexports.tSRestType = exports.tsRestType = tsRestType;\nexports.tSSatisfiesExpression = exports.tsSatisfiesExpression = tsSatisfiesExpression;\nexports.tSStringKeyword = exports.tsStringKeyword = tsStringKeyword;\nexports.tSSymbolKeyword = exports.tsSymbolKeyword = tsSymbolKeyword;\nexports.tSThisType = exports.tsThisType = tsThisType;\nexports.tSTupleType = exports.tsTupleType = tsTupleType;\nexports.tSTypeAliasDeclaration = exports.tsTypeAliasDeclaration = tsTypeAliasDeclaration;\nexports.tSTypeAnnotation = exports.tsTypeAnnotation = tsTypeAnnotation;\nexports.tSTypeAssertion = exports.tsTypeAssertion = tsTypeAssertion;\nexports.tSTypeLiteral = exports.tsTypeLiteral = tsTypeLiteral;\nexports.tSTypeOperator = exports.tsTypeOperator = tsTypeOperator;\nexports.tSTypeParameter = exports.tsTypeParameter = tsTypeParameter;\nexports.tSTypeParameterDeclaration = exports.tsTypeParameterDeclaration = tsTypeParameterDeclaration;\nexports.tSTypeParameterInstantiation = exports.tsTypeParameterInstantiation = tsTypeParameterInstantiation;\nexports.tSTypePredicate = exports.tsTypePredicate = tsTypePredicate;\nexports.tSTypeQuery = exports.tsTypeQuery = tsTypeQuery;\nexports.tSTypeReference = exports.tsTypeReference = tsTypeReference;\nexports.tSUndefinedKeyword = exports.tsUndefinedKeyword = tsUndefinedKeyword;\nexports.tSUnionType = exports.tsUnionType = tsUnionType;\nexports.tSUnknownKeyword = exports.tsUnknownKeyword = tsUnknownKeyword;\nexports.tSVoidKeyword = exports.tsVoidKeyword = tsVoidKeyword;\nexports.tupleExpression = tupleExpression;\nexports.tupleTypeAnnotation = tupleTypeAnnotation;\nexports.typeAlias = typeAlias;\nexports.typeAnnotation = typeAnnotation;\nexports.typeCastExpression = typeCastExpression;\nexports.typeParameter = typeParameter;\nexports.typeParameterDeclaration = typeParameterDeclaration;\nexports.typeParameterInstantiation = typeParameterInstantiation;\nexports.typeofTypeAnnotation = typeofTypeAnnotation;\nexports.unaryExpression = unaryExpression;\nexports.unionTypeAnnotation = unionTypeAnnotation;\nexports.updateExpression = updateExpression;\nexports.v8IntrinsicIdentifier = v8IntrinsicIdentifier;\nexports.variableDeclaration = variableDeclaration;\nexports.variableDeclarator = variableDeclarator;\nexports.variance = variance;\nexports.voidTypeAnnotation = voidTypeAnnotation;\nexports.whileStatement = whileStatement;\nexports.withStatement = withStatement;\nexports.yieldExpression = yieldExpression;\nvar _validateNode = require(\"../validateNode\");\nvar _deprecationWarning = require(\"../../utils/deprecationWarning\");\nfunction arrayExpression() {\n  let elements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  return (0, _validateNode.default)({\n    type: \"ArrayExpression\",\n    elements\n  });\n}\nfunction assignmentExpression(operator, left, right) {\n  return (0, _validateNode.default)({\n    type: \"AssignmentExpression\",\n    operator,\n    left,\n    right\n  });\n}\nfunction binaryExpression(operator, left, right) {\n  return (0, _validateNode.default)({\n    type: \"BinaryExpression\",\n    operator,\n    left,\n    right\n  });\n}\nfunction interpreterDirective(value) {\n  return (0, _validateNode.default)({\n    type: \"InterpreterDirective\",\n    value\n  });\n}\nfunction directive(value) {\n  return (0, _validateNode.default)({\n    type: \"Directive\",\n    value\n  });\n}\nfunction directiveLiteral(value) {\n  return (0, _validateNode.default)({\n    type: \"DirectiveLiteral\",\n    value\n  });\n}\nfunction blockStatement(body) {\n  let directives = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  return (0, _validateNode.default)({\n    type: \"BlockStatement\",\n    body,\n    directives\n  });\n}\nfunction breakStatement() {\n  let label = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  return (0, _validateNode.default)({\n    type: \"BreakStatement\",\n    label\n  });\n}\nfunction callExpression(callee, _arguments) {\n  return (0, _validateNode.default)({\n    type: \"CallExpression\",\n    callee,\n    arguments: _arguments\n  });\n}\nfunction catchClause() {\n  let param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  let body = arguments.length > 1 ? arguments[1] : undefined;\n  return (0, _validateNode.default)({\n    type: \"CatchClause\",\n    param,\n    body\n  });\n}\nfunction conditionalExpression(test, consequent, alternate) {\n  return (0, _validateNode.default)({\n    type: \"ConditionalExpression\",\n    test,\n    consequent,\n    alternate\n  });\n}\nfunction continueStatement() {\n  let label = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  return (0, _validateNode.default)({\n    type: \"ContinueStatement\",\n    label\n  });\n}\nfunction debuggerStatement() {\n  return {\n    type: \"DebuggerStatement\"\n  };\n}\nfunction doWhileStatement(test, body) {\n  return (0, _validateNode.default)({\n    type: \"DoWhileStatement\",\n    test,\n    body\n  });\n}\nfunction emptyStatement() {\n  return {\n    type: \"EmptyStatement\"\n  };\n}\nfunction expressionStatement(expression) {\n  return (0, _validateNode.default)({\n    type: \"ExpressionStatement\",\n    expression\n  });\n}\nfunction file(program) {\n  let comments = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  let tokens = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  return (0, _validateNode.default)({\n    type: \"File\",\n    program,\n    comments,\n    tokens\n  });\n}\nfunction forInStatement(left, right, body) {\n  return (0, _validateNode.default)({\n    type: \"ForInStatement\",\n    left,\n    right,\n    body\n  });\n}\nfunction forStatement() {\n  let init = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  let test = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  let update = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  let body = arguments.length > 3 ? arguments[3] : undefined;\n  return (0, _validateNode.default)({\n    type: \"ForStatement\",\n    init,\n    test,\n    update,\n    body\n  });\n}\nfunction functionDeclaration() {\n  let id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  let params = arguments.length > 1 ? arguments[1] : undefined;\n  let body = arguments.length > 2 ? arguments[2] : undefined;\n  let generator = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  let async = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  return (0, _validateNode.default)({\n    type: \"FunctionDeclaration\",\n    id,\n    params,\n    body,\n    generator,\n    async\n  });\n}\nfunction functionExpression() {\n  let id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  let params = arguments.length > 1 ? arguments[1] : undefined;\n  let body = arguments.length > 2 ? arguments[2] : undefined;\n  let generator = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  let async = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  return (0, _validateNode.default)({\n    type: \"FunctionExpression\",\n    id,\n    params,\n    body,\n    generator,\n    async\n  });\n}\nfunction identifier(name) {\n  return (0, _validateNode.default)({\n    type: \"Identifier\",\n    name\n  });\n}\nfunction ifStatement(test, consequent) {\n  let alternate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  return (0, _validateNode.default)({\n    type: \"IfStatement\",\n    test,\n    consequent,\n    alternate\n  });\n}\nfunction labeledStatement(label, body) {\n  return (0, _validateNode.default)({\n    type: \"LabeledStatement\",\n    label,\n    body\n  });\n}\nfunction stringLiteral(value) {\n  return (0, _validateNode.default)({\n    type: \"StringLiteral\",\n    value\n  });\n}\nfunction numericLiteral(value) {\n  return (0, _validateNode.default)({\n    type: \"NumericLiteral\",\n    value\n  });\n}\nfunction nullLiteral() {\n  return {\n    type: \"NullLiteral\"\n  };\n}\nfunction booleanLiteral(value) {\n  return (0, _validateNode.default)({\n    type: \"BooleanLiteral\",\n    value\n  });\n}\nfunction regExpLiteral(pattern) {\n  let flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n  return (0, _validateNode.default)({\n    type: \"RegExpLiteral\",\n    pattern,\n    flags\n  });\n}\nfunction logicalExpression(operator, left, right) {\n  return (0, _validateNode.default)({\n    type: \"LogicalExpression\",\n    operator,\n    left,\n    right\n  });\n}\nfunction memberExpression(object, property) {\n  let computed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  let optional = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  return (0, _validateNode.default)({\n    type: \"MemberExpression\",\n    object,\n    property,\n    computed,\n    optional\n  });\n}\nfunction newExpression(callee, _arguments) {\n  return (0, _validateNode.default)({\n    type: \"NewExpression\",\n    callee,\n    arguments: _arguments\n  });\n}\nfunction program(body) {\n  let directives = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  let sourceType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"script\";\n  let interpreter = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  return (0, _validateNode.default)({\n    type: \"Program\",\n    body,\n    directives,\n    sourceType,\n    interpreter,\n    sourceFile: null\n  });\n}\nfunction objectExpression(properties) {\n  return (0, _validateNode.default)({\n    type: \"ObjectExpression\",\n    properties\n  });\n}\nfunction objectMethod() {\n  let kind = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"method\";\n  let key = arguments.length > 1 ? arguments[1] : undefined;\n  let params = arguments.length > 2 ? arguments[2] : undefined;\n  let body = arguments.length > 3 ? arguments[3] : undefined;\n  let computed = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  let generator = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n  let async = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n  return (0, _validateNode.default)({\n    type: \"ObjectMethod\",\n    kind,\n    key,\n    params,\n    body,\n    computed,\n    generator,\n    async\n  });\n}\nfunction objectProperty(key, value) {\n  let computed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  let shorthand = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  let decorators = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  return (0, _validateNode.default)({\n    type: \"ObjectProperty\",\n    key,\n    value,\n    computed,\n    shorthand,\n    decorators\n  });\n}\nfunction restElement(argument) {\n  return (0, _validateNode.default)({\n    type: \"RestElement\",\n    argument\n  });\n}\nfunction returnStatement() {\n  let argument = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  return (0, _validateNode.default)({\n    type: \"ReturnStatement\",\n    argument\n  });\n}\nfunction sequenceExpression(expressions) {\n  return (0, _validateNode.default)({\n    type: \"SequenceExpression\",\n    expressions\n  });\n}\nfunction parenthesizedExpression(expression) {\n  return (0, _validateNode.default)({\n    type: \"ParenthesizedExpression\",\n    expression\n  });\n}\nfunction switchCase() {\n  let test = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  let consequent = arguments.length > 1 ? arguments[1] : undefined;\n  return (0, _validateNode.default)({\n    type: \"SwitchCase\",\n    test,\n    consequent\n  });\n}\nfunction switchStatement(discriminant, cases) {\n  return (0, _validateNode.default)({\n    type: \"SwitchStatement\",\n    discriminant,\n    cases\n  });\n}\nfunction thisExpression() {\n  return {\n    type: \"ThisExpression\"\n  };\n}\nfunction throwStatement(argument) {\n  return (0, _validateNode.default)({\n    type: \"ThrowStatement\",\n    argument\n  });\n}\nfunction tryStatement(block) {\n  let handler = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  let finalizer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  return (0, _validateNode.default)({\n    type: \"TryStatement\",\n    block,\n    handler,\n    finalizer\n  });\n}\nfunction unaryExpression(operator, argument) {\n  let prefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  return (0, _validateNode.default)({\n    type: \"UnaryExpression\",\n    operator,\n    argument,\n    prefix\n  });\n}\nfunction updateExpression(operator, argument) {\n  let prefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  return (0, _validateNode.default)({\n    type: \"UpdateExpression\",\n    operator,\n    argument,\n    prefix\n  });\n}\nfunction variableDeclaration(kind, declarations) {\n  return (0, _validateNode.default)({\n    type: \"VariableDeclaration\",\n    kind,\n    declarations\n  });\n}\nfunction variableDeclarator(id) {\n  let init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  return (0, _validateNode.default)({\n    type: \"VariableDeclarator\",\n    id,\n    init\n  });\n}\nfunction whileStatement(test, body) {\n  return (0, _validateNode.default)({\n    type: \"WhileStatement\",\n    test,\n    body\n  });\n}\nfunction withStatement(object, body) {\n  return (0, _validateNode.default)({\n    type: \"WithStatement\",\n    object,\n    body\n  });\n}\nfunction assignmentPattern(left, right) {\n  return (0, _validateNode.default)({\n    type: \"AssignmentPattern\",\n    left,\n    right\n  });\n}\nfunction arrayPattern(elements) {\n  return (0, _validateNode.default)({\n    type: \"ArrayPattern\",\n    elements\n  });\n}\nfunction arrowFunctionExpression(params, body) {\n  let async = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  return (0, _validateNode.default)({\n    type: \"ArrowFunctionExpression\",\n    params,\n    body,\n    async,\n    expression: null\n  });\n}\nfunction classBody(body) {\n  return (0, _validateNode.default)({\n    type: \"ClassBody\",\n    body\n  });\n}\nfunction classExpression() {\n  let id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  let superClass = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  let body = arguments.length > 2 ? arguments[2] : undefined;\n  let decorators = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  return (0, _validateNode.default)({\n    type: \"ClassExpression\",\n    id,\n    superClass,\n    body,\n    decorators\n  });\n}\nfunction classDeclaration(id) {\n  let superClass = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  let body = arguments.length > 2 ? arguments[2] : undefined;\n  let decorators = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  return (0, _validateNode.default)({\n    type: \"ClassDeclaration\",\n    id,\n    superClass,\n    body,\n    decorators\n  });\n}\nfunction exportAllDeclaration(source) {\n  return (0, _validateNode.default)({\n    type: \"ExportAllDeclaration\",\n    source\n  });\n}\nfunction exportDefaultDeclaration(declaration) {\n  return (0, _validateNode.default)({\n    type: \"ExportDefaultDeclaration\",\n    declaration\n  });\n}\nfunction exportNamedDeclaration() {\n  let declaration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  let specifiers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  let source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  return (0, _validateNode.default)({\n    type: \"ExportNamedDeclaration\",\n    declaration,\n    specifiers,\n    source\n  });\n}\nfunction exportSpecifier(local, exported) {\n  return (0, _validateNode.default)({\n    type: \"ExportSpecifier\",\n    local,\n    exported\n  });\n}\nfunction forOfStatement(left, right, body) {\n  let _await = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  return (0, _validateNode.default)({\n    type: \"ForOfStatement\",\n    left,\n    right,\n    body,\n    await: _await\n  });\n}\nfunction importDeclaration(specifiers, source) {\n  return (0, _validateNode.default)({\n    type: \"ImportDeclaration\",\n    specifiers,\n    source\n  });\n}\nfunction importDefaultSpecifier(local) {\n  return (0, _validateNode.default)({\n    type: \"ImportDefaultSpecifier\",\n    local\n  });\n}\nfunction importNamespaceSpecifier(local) {\n  return (0, _validateNode.default)({\n    type: \"ImportNamespaceSpecifier\",\n    local\n  });\n}\nfunction importSpecifier(local, imported) {\n  return (0, _validateNode.default)({\n    type: \"ImportSpecifier\",\n    local,\n    imported\n  });\n}\nfunction metaProperty(meta, property) {\n  return (0, _validateNode.default)({\n    type: \"MetaProperty\",\n    meta,\n    property\n  });\n}\nfunction classMethod() {\n  let kind = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"method\";\n  let key = arguments.length > 1 ? arguments[1] : undefined;\n  let params = arguments.length > 2 ? arguments[2] : undefined;\n  let body = arguments.length > 3 ? arguments[3] : undefined;\n  let computed = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  let _static = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n  let generator = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n  let async = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;\n  return (0, _validateNode.default)({\n    type: \"ClassMethod\",\n    kind,\n    key,\n    params,\n    body,\n    computed,\n    static: _static,\n    generator,\n    async\n  });\n}\nfunction objectPattern(properties) {\n  return (0, _validateNode.default)({\n    type: \"ObjectPattern\",\n    properties\n  });\n}\nfunction spreadElement(argument) {\n  return (0, _validateNode.default)({\n    type: \"SpreadElement\",\n    argument\n  });\n}\nfunction _super() {\n  return {\n    type: \"Super\"\n  };\n}\nfunction taggedTemplateExpression(tag, quasi) {\n  return (0, _validateNode.default)({\n    type: \"TaggedTemplateExpression\",\n    tag,\n    quasi\n  });\n}\nfunction templateElement(value) {\n  let tail = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  return (0, _validateNode.default)({\n    type: \"TemplateElement\",\n    value,\n    tail\n  });\n}\nfunction templateLiteral(quasis, expressions) {\n  return (0, _validateNode.default)({\n    type: \"TemplateLiteral\",\n    quasis,\n    expressions\n  });\n}\nfunction yieldExpression() {\n  let argument = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  let delegate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  return (0, _validateNode.default)({\n    type: \"YieldExpression\",\n    argument,\n    delegate\n  });\n}\nfunction awaitExpression(argument) {\n  return (0, _validateNode.default)({\n    type: \"AwaitExpression\",\n    argument\n  });\n}\nfunction _import() {\n  return {\n    type: \"Import\"\n  };\n}\nfunction bigIntLiteral(value) {\n  return (0, _validateNode.default)({\n    type: \"BigIntLiteral\",\n    value\n  });\n}\nfunction exportNamespaceSpecifier(exported) {\n  return (0, _validateNode.default)({\n    type: \"ExportNamespaceSpecifier\",\n    exported\n  });\n}\nfunction optionalMemberExpression(object, property) {\n  let computed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  let optional = arguments.length > 3 ? arguments[3] : undefined;\n  return (0, _validateNode.default)({\n    type: \"OptionalMemberExpression\",\n    object,\n    property,\n    computed,\n    optional\n  });\n}\nfunction optionalCallExpression(callee, _arguments, optional) {\n  return (0, _validateNode.default)({\n    type: \"OptionalCallExpression\",\n    callee,\n    arguments: _arguments,\n    optional\n  });\n}\nfunction classProperty(key) {\n  let value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  let typeAnnotation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  let decorators = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  let computed = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  let _static = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n  return (0, _validateNode.default)({\n    type: \"ClassProperty\",\n    key,\n    value,\n    typeAnnotation,\n    decorators,\n    computed,\n    static: _static\n  });\n}\nfunction classAccessorProperty(key) {\n  let value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  let typeAnnotation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  let decorators = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  let computed = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  let _static = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n  return (0, _validateNode.default)({\n    type: \"ClassAccessorProperty\",\n    key,\n    value,\n    typeAnnotation,\n    decorators,\n    computed,\n    static: _static\n  });\n}\nfunction classPrivateProperty(key) {\n  let value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  let decorators = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  let _static = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  return (0, _validateNode.default)({\n    type: \"ClassPrivateProperty\",\n    key,\n    value,\n    decorators,\n    static: _static\n  });\n}\nfunction classPrivateMethod() {\n  let kind = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"method\";\n  let key = arguments.length > 1 ? arguments[1] : undefined;\n  let params = arguments.length > 2 ? arguments[2] : undefined;\n  let body = arguments.length > 3 ? arguments[3] : undefined;\n  let _static = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  return (0, _validateNode.default)({\n    type: \"ClassPrivateMethod\",\n    kind,\n    key,\n    params,\n    body,\n    static: _static\n  });\n}\nfunction privateName(id) {\n  return (0, _validateNode.default)({\n    type: \"PrivateName\",\n    id\n  });\n}\nfunction staticBlock(body) {\n  return (0, _validateNode.default)({\n    type: \"StaticBlock\",\n    body\n  });\n}\nfunction anyTypeAnnotation() {\n  return {\n    type: \"AnyTypeAnnotation\"\n  };\n}\nfunction arrayTypeAnnotation(elementType) {\n  return (0, _validateNode.default)({\n    type: \"ArrayTypeAnnotation\",\n    elementType\n  });\n}\nfunction booleanTypeAnnotation() {\n  return {\n    type: \"BooleanTypeAnnotation\"\n  };\n}\nfunction booleanLiteralTypeAnnotation(value) {\n  return (0, _validateNode.default)({\n    type: \"BooleanLiteralTypeAnnotation\",\n    value\n  });\n}\nfunction nullLiteralTypeAnnotation() {\n  return {\n    type: \"NullLiteralTypeAnnotation\"\n  };\n}\nfunction classImplements(id) {\n  let typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  return (0, _validateNode.default)({\n    type: \"ClassImplements\",\n    id,\n    typeParameters\n  });\n}\nfunction declareClass(id) {\n  let typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  let _extends = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  let body = arguments.length > 3 ? arguments[3] : undefined;\n  return (0, _validateNode.default)({\n    type: \"DeclareClass\",\n    id,\n    typeParameters,\n    extends: _extends,\n    body\n  });\n}\nfunction declareFunction(id) {\n  return (0, _validateNode.default)({\n    type: \"DeclareFunction\",\n    id\n  });\n}\nfunction declareInterface(id) {\n  let typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  let _extends = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  let body = arguments.length > 3 ? arguments[3] : undefined;\n  return (0, _validateNode.default)({\n    type: \"DeclareInterface\",\n    id,\n    typeParameters,\n    extends: _extends,\n    body\n  });\n}\nfunction declareModule(id, body) {\n  let kind = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  return (0, _validateNode.default)({\n    type: \"DeclareModule\",\n    id,\n    body,\n    kind\n  });\n}\nfunction declareModuleExports(typeAnnotation) {\n  return (0, _validateNode.default)({\n    type: \"DeclareModuleExports\",\n    typeAnnotation\n  });\n}\nfunction declareTypeAlias(id) {\n  let typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  let right = arguments.length > 2 ? arguments[2] : undefined;\n  return (0, _validateNode.default)({\n    type: \"DeclareTypeAlias\",\n    id,\n    typeParameters,\n    right\n  });\n}\nfunction declareOpaqueType(id) {\n  let typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  let supertype = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  return (0, _validateNode.default)({\n    type: \"DeclareOpaqueType\",\n    id,\n    typeParameters,\n    supertype\n  });\n}\nfunction declareVariable(id) {\n  return (0, _validateNode.default)({\n    type: \"DeclareVariable\",\n    id\n  });\n}\nfunction declareExportDeclaration() {\n  let declaration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  let specifiers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  let source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  return (0, _validateNode.default)({\n    type: \"DeclareExportDeclaration\",\n    declaration,\n    specifiers,\n    source\n  });\n}\nfunction declareExportAllDeclaration(source) {\n  return (0, _validateNode.default)({\n    type: \"DeclareExportAllDeclaration\",\n    source\n  });\n}\nfunction declaredPredicate(value) {\n  return (0, _validateNode.default)({\n    type: \"DeclaredPredicate\",\n    value\n  });\n}\nfunction existsTypeAnnotation() {\n  return {\n    type: \"ExistsTypeAnnotation\"\n  };\n}\nfunction functionTypeAnnotation() {\n  let typeParameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  let params = arguments.length > 1 ? arguments[1] : undefined;\n  let rest = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  let returnType = arguments.length > 3 ? arguments[3] : undefined;\n  return (0, _validateNode.default)({\n    type: \"FunctionTypeAnnotation\",\n    typeParameters,\n    params,\n    rest,\n    returnType\n  });\n}\nfunction functionTypeParam() {\n  let name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  let typeAnnotation = arguments.length > 1 ? arguments[1] : undefined;\n  return (0, _validateNode.default)({\n    type: \"FunctionTypeParam\",\n    name,\n    typeAnnotation\n  });\n}\nfunction genericTypeAnnotation(id) {\n  let typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  return (0, _validateNode.default)({\n    type: \"GenericTypeAnnotation\",\n    id,\n    typeParameters\n  });\n}\nfunction inferredPredicate() {\n  return {\n    type: \"InferredPredicate\"\n  };\n}\nfunction interfaceExtends(id) {\n  let typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  return (0, _validateNode.default)({\n    type: \"InterfaceExtends\",\n    id,\n    typeParameters\n  });\n}\nfunction interfaceDeclaration(id) {\n  let typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  let _extends = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  let body = arguments.length > 3 ? arguments[3] : undefined;\n  return (0, _validateNode.default)({\n    type: \"InterfaceDeclaration\",\n    id,\n    typeParameters,\n    extends: _extends,\n    body\n  });\n}\nfunction interfaceTypeAnnotation() {\n  let _extends = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  let body = arguments.length > 1 ? arguments[1] : undefined;\n  return (0, _validateNode.default)({\n    type: \"InterfaceTypeAnnotation\",\n    extends: _extends,\n    body\n  });\n}\nfunction intersectionTypeAnnotation(types) {\n  return (0, _validateNode.default)({\n    type: \"IntersectionTypeAnnotation\",\n    types\n  });\n}\nfunction mixedTypeAnnotation() {\n  return {\n    type: \"MixedTypeAnnotation\"\n  };\n}\nfunction emptyTypeAnnotation() {\n  return {\n    type: \"EmptyTypeAnnotation\"\n  };\n}\nfunction nullableTypeAnnotation(typeAnnotation) {\n  return (0, _validateNode.default)({\n    type: \"NullableTypeAnnotation\",\n    typeAnnotation\n  });\n}\nfunction numberLiteralTypeAnnotation(value) {\n  return (0, _validateNode.default)({\n    type: \"NumberLiteralTypeAnnotation\",\n    value\n  });\n}\nfunction numberTypeAnnotation() {\n  return {\n    type: \"NumberTypeAnnotation\"\n  };\n}\nfunction objectTypeAnnotation(properties) {\n  let indexers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  let callProperties = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  let internalSlots = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n  let exact = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  return (0, _validateNode.default)({\n    type: \"ObjectTypeAnnotation\",\n    properties,\n    indexers,\n    callProperties,\n    internalSlots,\n    exact\n  });\n}\nfunction objectTypeInternalSlot(id, value, optional, _static, method) {\n  return (0, _validateNode.default)({\n    type: \"ObjectTypeInternalSlot\",\n    id,\n    value,\n    optional,\n    static: _static,\n    method\n  });\n}\nfunction objectTypeCallProperty(value) {\n  return (0, _validateNode.default)({\n    type: \"ObjectTypeCallProperty\",\n    value,\n    static: null\n  });\n}\nfunction objectTypeIndexer() {\n  let id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  let key = arguments.length > 1 ? arguments[1] : undefined;\n  let value = arguments.length > 2 ? arguments[2] : undefined;\n  let variance = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  return (0, _validateNode.default)({\n    type: \"ObjectTypeIndexer\",\n    id,\n    key,\n    value,\n    variance,\n    static: null\n  });\n}\nfunction objectTypeProperty(key, value) {\n  let variance = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  return (0, _validateNode.default)({\n    type: \"ObjectTypeProperty\",\n    key,\n    value,\n    variance,\n    kind: null,\n    method: null,\n    optional: null,\n    proto: null,\n    static: null\n  });\n}\nfunction objectTypeSpreadProperty(argument) {\n  return (0, _validateNode.default)({\n    type: \"ObjectTypeSpreadProperty\",\n    argument\n  });\n}\nfunction opaqueType(id) {\n  let typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  let supertype = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  let impltype = arguments.length > 3 ? arguments[3] : undefined;\n  return (0, _validateNode.default)({\n    type: \"OpaqueType\",\n    id,\n    typeParameters,\n    supertype,\n    impltype\n  });\n}\nfunction qualifiedTypeIdentifier(id, qualification) {\n  return (0, _validateNode.default)({\n    type: \"QualifiedTypeIdentifier\",\n    id,\n    qualification\n  });\n}\nfunction stringLiteralTypeAnnotation(value) {\n  return (0, _validateNode.default)({\n    type: \"StringLiteralTypeAnnotation\",\n    value\n  });\n}\nfunction stringTypeAnnotation() {\n  return {\n    type: \"StringTypeAnnotation\"\n  };\n}\nfunction symbolTypeAnnotation() {\n  return {\n    type: \"SymbolTypeAnnotation\"\n  };\n}\nfunction thisTypeAnnotation() {\n  return {\n    type: \"ThisTypeAnnotation\"\n  };\n}\nfunction tupleTypeAnnotation(types) {\n  return (0, _validateNode.default)({\n    type: \"TupleTypeAnnotation\",\n    types\n  });\n}\nfunction typeofTypeAnnotation(argument) {\n  return (0, _validateNode.default)({\n    type: \"TypeofTypeAnnotation\",\n    argument\n  });\n}\nfunction typeAlias(id) {\n  let typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  let right = arguments.length > 2 ? arguments[2] : undefined;\n  return (0, _validateNode.default)({\n    type: \"TypeAlias\",\n    id,\n    typeParameters,\n    right\n  });\n}\nfunction typeAnnotation(typeAnnotation) {\n  return (0, _validateNode.default)({\n    type: \"TypeAnnotation\",\n    typeAnnotation\n  });\n}\nfunction typeCastExpression(expression, typeAnnotation) {\n  return (0, _validateNode.default)({\n    type: \"TypeCastExpression\",\n    expression,\n    typeAnnotation\n  });\n}\nfunction typeParameter() {\n  let bound = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  let _default = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  let variance = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  return (0, _validateNode.default)({\n    type: \"TypeParameter\",\n    bound,\n    default: _default,\n    variance,\n    name: null\n  });\n}\nfunction typeParameterDeclaration(params) {\n  return (0, _validateNode.default)({\n    type: \"TypeParameterDeclaration\",\n    params\n  });\n}\nfunction typeParameterInstantiation(params) {\n  return (0, _validateNode.default)({\n    type: \"TypeParameterInstantiation\",\n    params\n  });\n}\nfunction unionTypeAnnotation(types) {\n  return (0, _validateNode.default)({\n    type: \"UnionTypeAnnotation\",\n    types\n  });\n}\nfunction variance(kind) {\n  return (0, _validateNode.default)({\n    type: \"Variance\",\n    kind\n  });\n}\nfunction voidTypeAnnotation() {\n  return {\n    type: \"VoidTypeAnnotation\"\n  };\n}\nfunction enumDeclaration(id, body) {\n  return (0, _validateNode.default)({\n    type: \"EnumDeclaration\",\n    id,\n    body\n  });\n}\nfunction enumBooleanBody(members) {\n  return (0, _validateNode.default)({\n    type: \"EnumBooleanBody\",\n    members,\n    explicitType: null,\n    hasUnknownMembers: null\n  });\n}\nfunction enumNumberBody(members) {\n  return (0, _validateNode.default)({\n    type: \"EnumNumberBody\",\n    members,\n    explicitType: null,\n    hasUnknownMembers: null\n  });\n}\nfunction enumStringBody(members) {\n  return (0, _validateNode.default)({\n    type: \"EnumStringBody\",\n    members,\n    explicitType: null,\n    hasUnknownMembers: null\n  });\n}\nfunction enumSymbolBody(members) {\n  return (0, _validateNode.default)({\n    type: \"EnumSymbolBody\",\n    members,\n    hasUnknownMembers: null\n  });\n}\nfunction enumBooleanMember(id) {\n  return (0, _validateNode.default)({\n    type: \"EnumBooleanMember\",\n    id,\n    init: null\n  });\n}\nfunction enumNumberMember(id, init) {\n  return (0, _validateNode.default)({\n    type: \"EnumNumberMember\",\n    id,\n    init\n  });\n}\nfunction enumStringMember(id, init) {\n  return (0, _validateNode.default)({\n    type: \"EnumStringMember\",\n    id,\n    init\n  });\n}\nfunction enumDefaultedMember(id) {\n  return (0, _validateNode.default)({\n    type: \"EnumDefaultedMember\",\n    id\n  });\n}\nfunction indexedAccessType(objectType, indexType) {\n  return (0, _validateNode.default)({\n    type: \"IndexedAccessType\",\n    objectType,\n    indexType\n  });\n}\nfunction optionalIndexedAccessType(objectType, indexType) {\n  return (0, _validateNode.default)({\n    type: \"OptionalIndexedAccessType\",\n    objectType,\n    indexType,\n    optional: null\n  });\n}\nfunction jsxAttribute(name) {\n  let value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  return (0, _validateNode.default)({\n    type: \"JSXAttribute\",\n    name,\n    value\n  });\n}\nfunction jsxClosingElement(name) {\n  return (0, _validateNode.default)({\n    type: \"JSXClosingElement\",\n    name\n  });\n}\nfunction jsxElement(openingElement) {\n  let closingElement = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  let children = arguments.length > 2 ? arguments[2] : undefined;\n  let selfClosing = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  return (0, _validateNode.default)({\n    type: \"JSXElement\",\n    openingElement,\n    closingElement,\n    children,\n    selfClosing\n  });\n}\nfunction jsxEmptyExpression() {\n  return {\n    type: \"JSXEmptyExpression\"\n  };\n}\nfunction jsxExpressionContainer(expression) {\n  return (0, _validateNode.default)({\n    type: \"JSXExpressionContainer\",\n    expression\n  });\n}\nfunction jsxSpreadChild(expression) {\n  return (0, _validateNode.default)({\n    type: \"JSXSpreadChild\",\n    expression\n  });\n}\nfunction jsxIdentifier(name) {\n  return (0, _validateNode.default)({\n    type: \"JSXIdentifier\",\n    name\n  });\n}\nfunction jsxMemberExpression(object, property) {\n  return (0, _validateNode.default)({\n    type: \"JSXMemberExpression\",\n    object,\n    property\n  });\n}\nfunction jsxNamespacedName(namespace, name) {\n  return (0, _validateNode.default)({\n    type: \"JSXNamespacedName\",\n    namespace,\n    name\n  });\n}\nfunction jsxOpeningElement(name, attributes) {\n  let selfClosing = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  return (0, _validateNode.default)({\n    type: \"JSXOpeningElement\",\n    name,\n    attributes,\n    selfClosing\n  });\n}\nfunction jsxSpreadAttribute(argument) {\n  return (0, _validateNode.default)({\n    type: \"JSXSpreadAttribute\",\n    argument\n  });\n}\nfunction jsxText(value) {\n  return (0, _validateNode.default)({\n    type: \"JSXText\",\n    value\n  });\n}\nfunction jsxFragment(openingFragment, closingFragment, children) {\n  return (0, _validateNode.default)({\n    type: \"JSXFragment\",\n    openingFragment,\n    closingFragment,\n    children\n  });\n}\nfunction jsxOpeningFragment() {\n  return {\n    type: \"JSXOpeningFragment\"\n  };\n}\nfunction jsxClosingFragment() {\n  return {\n    type: \"JSXClosingFragment\"\n  };\n}\nfunction noop() {\n  return {\n    type: \"Noop\"\n  };\n}\nfunction placeholder(expectedNode, name) {\n  return (0, _validateNode.default)({\n    type: \"Placeholder\",\n    expectedNode,\n    name\n  });\n}\nfunction v8IntrinsicIdentifier(name) {\n  return (0, _validateNode.default)({\n    type: \"V8IntrinsicIdentifier\",\n    name\n  });\n}\nfunction argumentPlaceholder() {\n  return {\n    type: \"ArgumentPlaceholder\"\n  };\n}\nfunction bindExpression(object, callee) {\n  return (0, _validateNode.default)({\n    type: \"BindExpression\",\n    object,\n    callee\n  });\n}\nfunction importAttribute(key, value) {\n  return (0, _validateNode.default)({\n    type: \"ImportAttribute\",\n    key,\n    value\n  });\n}\nfunction decorator(expression) {\n  return (0, _validateNode.default)({\n    type: \"Decorator\",\n    expression\n  });\n}\nfunction doExpression(body) {\n  let async = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  return (0, _validateNode.default)({\n    type: \"DoExpression\",\n    body,\n    async\n  });\n}\nfunction exportDefaultSpecifier(exported) {\n  return (0, _validateNode.default)({\n    type: \"ExportDefaultSpecifier\",\n    exported\n  });\n}\nfunction recordExpression(properties) {\n  return (0, _validateNode.default)({\n    type: \"RecordExpression\",\n    properties\n  });\n}\nfunction tupleExpression() {\n  let elements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  return (0, _validateNode.default)({\n    type: \"TupleExpression\",\n    elements\n  });\n}\nfunction decimalLiteral(value) {\n  return (0, _validateNode.default)({\n    type: \"DecimalLiteral\",\n    value\n  });\n}\nfunction moduleExpression(body) {\n  return (0, _validateNode.default)({\n    type: \"ModuleExpression\",\n    body\n  });\n}\nfunction topicReference() {\n  return {\n    type: \"TopicReference\"\n  };\n}\nfunction pipelineTopicExpression(expression) {\n  return (0, _validateNode.default)({\n    type: \"PipelineTopicExpression\",\n    expression\n  });\n}\nfunction pipelineBareFunction(callee) {\n  return (0, _validateNode.default)({\n    type: \"PipelineBareFunction\",\n    callee\n  });\n}\nfunction pipelinePrimaryTopicReference() {\n  return {\n    type: \"PipelinePrimaryTopicReference\"\n  };\n}\nfunction tsParameterProperty(parameter) {\n  return (0, _validateNode.default)({\n    type: \"TSParameterProperty\",\n    parameter\n  });\n}\nfunction tsDeclareFunction() {\n  let id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  let typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  let params = arguments.length > 2 ? arguments[2] : undefined;\n  let returnType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  return (0, _validateNode.default)({\n    type: \"TSDeclareFunction\",\n    id,\n    typeParameters,\n    params,\n    returnType\n  });\n}\nfunction tsDeclareMethod() {\n  let decorators = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  let key = arguments.length > 1 ? arguments[1] : undefined;\n  let typeParameters = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  let params = arguments.length > 3 ? arguments[3] : undefined;\n  let returnType = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  return (0, _validateNode.default)({\n    type: \"TSDeclareMethod\",\n    decorators,\n    key,\n    typeParameters,\n    params,\n    returnType\n  });\n}\nfunction tsQualifiedName(left, right) {\n  return (0, _validateNode.default)({\n    type: \"TSQualifiedName\",\n    left,\n    right\n  });\n}\nfunction tsCallSignatureDeclaration() {\n  let typeParameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  let parameters = arguments.length > 1 ? arguments[1] : undefined;\n  let typeAnnotation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  return (0, _validateNode.default)({\n    type: \"TSCallSignatureDeclaration\",\n    typeParameters,\n    parameters,\n    typeAnnotation\n  });\n}\nfunction tsConstructSignatureDeclaration() {\n  let typeParameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  let parameters = arguments.length > 1 ? arguments[1] : undefined;\n  let typeAnnotation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  return (0, _validateNode.default)({\n    type: \"TSConstructSignatureDeclaration\",\n    typeParameters,\n    parameters,\n    typeAnnotation\n  });\n}\nfunction tsPropertySignature(key) {\n  let typeAnnotation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  let initializer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  return (0, _validateNode.default)({\n    type: \"TSPropertySignature\",\n    key,\n    typeAnnotation,\n    initializer,\n    kind: null\n  });\n}\nfunction tsMethodSignature(key) {\n  let typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  let parameters = arguments.length > 2 ? arguments[2] : undefined;\n  let typeAnnotation = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  return (0, _validateNode.default)({\n    type: \"TSMethodSignature\",\n    key,\n    typeParameters,\n    parameters,\n    typeAnnotation,\n    kind: null\n  });\n}\nfunction tsIndexSignature(parameters) {\n  let typeAnnotation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  return (0, _validateNode.default)({\n    type: \"TSIndexSignature\",\n    parameters,\n    typeAnnotation\n  });\n}\nfunction tsAnyKeyword() {\n  return {\n    type: \"TSAnyKeyword\"\n  };\n}\nfunction tsBooleanKeyword() {\n  return {\n    type: \"TSBooleanKeyword\"\n  };\n}\nfunction tsBigIntKeyword() {\n  return {\n    type: \"TSBigIntKeyword\"\n  };\n}\nfunction tsIntrinsicKeyword() {\n  return {\n    type: \"TSIntrinsicKeyword\"\n  };\n}\nfunction tsNeverKeyword() {\n  return {\n    type: \"TSNeverKeyword\"\n  };\n}\nfunction tsNullKeyword() {\n  return {\n    type: \"TSNullKeyword\"\n  };\n}\nfunction tsNumberKeyword() {\n  return {\n    type: \"TSNumberKeyword\"\n  };\n}\nfunction tsObjectKeyword() {\n  return {\n    type: \"TSObjectKeyword\"\n  };\n}\nfunction tsStringKeyword() {\n  return {\n    type: \"TSStringKeyword\"\n  };\n}\nfunction tsSymbolKeyword() {\n  return {\n    type: \"TSSymbolKeyword\"\n  };\n}\nfunction tsUndefinedKeyword() {\n  return {\n    type: \"TSUndefinedKeyword\"\n  };\n}\nfunction tsUnknownKeyword() {\n  return {\n    type: \"TSUnknownKeyword\"\n  };\n}\nfunction tsVoidKeyword() {\n  return {\n    type: \"TSVoidKeyword\"\n  };\n}\nfunction tsThisType() {\n  return {\n    type: \"TSThisType\"\n  };\n}\nfunction tsFunctionType() {\n  let typeParameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  let parameters = arguments.length > 1 ? arguments[1] : undefined;\n  let typeAnnotation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  return (0, _validateNode.default)({\n    type: \"TSFunctionType\",\n    typeParameters,\n    parameters,\n    typeAnnotation\n  });\n}\nfunction tsConstructorType() {\n  let typeParameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  let parameters = arguments.length > 1 ? arguments[1] : undefined;\n  let typeAnnotation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  return (0, _validateNode.default)({\n    type: \"TSConstructorType\",\n    typeParameters,\n    parameters,\n    typeAnnotation\n  });\n}\nfunction tsTypeReference(typeName) {\n  let typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  return (0, _validateNode.default)({\n    type: \"TSTypeReference\",\n    typeName,\n    typeParameters\n  });\n}\nfunction tsTypePredicate(parameterName) {\n  let typeAnnotation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  let asserts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  return (0, _validateNode.default)({\n    type: \"TSTypePredicate\",\n    parameterName,\n    typeAnnotation,\n    asserts\n  });\n}\nfunction tsTypeQuery(exprName) {\n  let typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  return (0, _validateNode.default)({\n    type: \"TSTypeQuery\",\n    exprName,\n    typeParameters\n  });\n}\nfunction tsTypeLiteral(members) {\n  return (0, _validateNode.default)({\n    type: \"TSTypeLiteral\",\n    members\n  });\n}\nfunction tsArrayType(elementType) {\n  return (0, _validateNode.default)({\n    type: \"TSArrayType\",\n    elementType\n  });\n}\nfunction tsTupleType(elementTypes) {\n  return (0, _validateNode.default)({\n    type: \"TSTupleType\",\n    elementTypes\n  });\n}\nfunction tsOptionalType(typeAnnotation) {\n  return (0, _validateNode.default)({\n    type: \"TSOptionalType\",\n    typeAnnotation\n  });\n}\nfunction tsRestType(typeAnnotation) {\n  return (0, _validateNode.default)({\n    type: \"TSRestType\",\n    typeAnnotation\n  });\n}\nfunction tsNamedTupleMember(label, elementType) {\n  let optional = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  return (0, _validateNode.default)({\n    type: \"TSNamedTupleMember\",\n    label,\n    elementType,\n    optional\n  });\n}\nfunction tsUnionType(types) {\n  return (0, _validateNode.default)({\n    type: \"TSUnionType\",\n    types\n  });\n}\nfunction tsIntersectionType(types) {\n  return (0, _validateNode.default)({\n    type: \"TSIntersectionType\",\n    types\n  });\n}\nfunction tsConditionalType(checkType, extendsType, trueType, falseType) {\n  return (0, _validateNode.default)({\n    type: \"TSConditionalType\",\n    checkType,\n    extendsType,\n    trueType,\n    falseType\n  });\n}\nfunction tsInferType(typeParameter) {\n  return (0, _validateNode.default)({\n    type: \"TSInferType\",\n    typeParameter\n  });\n}\nfunction tsParenthesizedType(typeAnnotation) {\n  return (0, _validateNode.default)({\n    type: \"TSParenthesizedType\",\n    typeAnnotation\n  });\n}\nfunction tsTypeOperator(typeAnnotation) {\n  return (0, _validateNode.default)({\n    type: \"TSTypeOperator\",\n    typeAnnotation,\n    operator: null\n  });\n}\nfunction tsIndexedAccessType(objectType, indexType) {\n  return (0, _validateNode.default)({\n    type: \"TSIndexedAccessType\",\n    objectType,\n    indexType\n  });\n}\nfunction tsMappedType(typeParameter) {\n  let typeAnnotation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  let nameType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  return (0, _validateNode.default)({\n    type: \"TSMappedType\",\n    typeParameter,\n    typeAnnotation,\n    nameType\n  });\n}\nfunction tsLiteralType(literal) {\n  return (0, _validateNode.default)({\n    type: \"TSLiteralType\",\n    literal\n  });\n}\nfunction tsExpressionWithTypeArguments(expression) {\n  let typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  return (0, _validateNode.default)({\n    type: \"TSExpressionWithTypeArguments\",\n    expression,\n    typeParameters\n  });\n}\nfunction tsInterfaceDeclaration(id) {\n  let typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  let _extends = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  let body = arguments.length > 3 ? arguments[3] : undefined;\n  return (0, _validateNode.default)({\n    type: \"TSInterfaceDeclaration\",\n    id,\n    typeParameters,\n    extends: _extends,\n    body\n  });\n}\nfunction tsInterfaceBody(body) {\n  return (0, _validateNode.default)({\n    type: \"TSInterfaceBody\",\n    body\n  });\n}\nfunction tsTypeAliasDeclaration(id) {\n  let typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  let typeAnnotation = arguments.length > 2 ? arguments[2] : undefined;\n  return (0, _validateNode.default)({\n    type: \"TSTypeAliasDeclaration\",\n    id,\n    typeParameters,\n    typeAnnotation\n  });\n}\nfunction tsInstantiationExpression(expression) {\n  let typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  return (0, _validateNode.default)({\n    type: \"TSInstantiationExpression\",\n    expression,\n    typeParameters\n  });\n}\nfunction tsAsExpression(expression, typeAnnotation) {\n  return (0, _validateNode.default)({\n    type: \"TSAsExpression\",\n    expression,\n    typeAnnotation\n  });\n}\nfunction tsSatisfiesExpression(expression, typeAnnotation) {\n  return (0, _validateNode.default)({\n    type: \"TSSatisfiesExpression\",\n    expression,\n    typeAnnotation\n  });\n}\nfunction tsTypeAssertion(typeAnnotation, expression) {\n  return (0, _validateNode.default)({\n    type: \"TSTypeAssertion\",\n    typeAnnotation,\n    expression\n  });\n}\nfunction tsEnumDeclaration(id, members) {\n  return (0, _validateNode.default)({\n    type: \"TSEnumDeclaration\",\n    id,\n    members\n  });\n}\nfunction tsEnumMember(id) {\n  let initializer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  return (0, _validateNode.default)({\n    type: \"TSEnumMember\",\n    id,\n    initializer\n  });\n}\nfunction tsModuleDeclaration(id, body) {\n  return (0, _validateNode.default)({\n    type: \"TSModuleDeclaration\",\n    id,\n    body\n  });\n}\nfunction tsModuleBlock(body) {\n  return (0, _validateNode.default)({\n    type: \"TSModuleBlock\",\n    body\n  });\n}\nfunction tsImportType(argument) {\n  let qualifier = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  let typeParameters = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  return (0, _validateNode.default)({\n    type: \"TSImportType\",\n    argument,\n    qualifier,\n    typeParameters\n  });\n}\nfunction tsImportEqualsDeclaration(id, moduleReference) {\n  return (0, _validateNode.default)({\n    type: \"TSImportEqualsDeclaration\",\n    id,\n    moduleReference,\n    isExport: null\n  });\n}\nfunction tsExternalModuleReference(expression) {\n  return (0, _validateNode.default)({\n    type: \"TSExternalModuleReference\",\n    expression\n  });\n}\nfunction tsNonNullExpression(expression) {\n  return (0, _validateNode.default)({\n    type: \"TSNonNullExpression\",\n    expression\n  });\n}\nfunction tsExportAssignment(expression) {\n  return (0, _validateNode.default)({\n    type: \"TSExportAssignment\",\n    expression\n  });\n}\nfunction tsNamespaceExportDeclaration(id) {\n  return (0, _validateNode.default)({\n    type: \"TSNamespaceExportDeclaration\",\n    id\n  });\n}\nfunction tsTypeAnnotation(typeAnnotation) {\n  return (0, _validateNode.default)({\n    type: \"TSTypeAnnotation\",\n    typeAnnotation\n  });\n}\nfunction tsTypeParameterInstantiation(params) {\n  return (0, _validateNode.default)({\n    type: \"TSTypeParameterInstantiation\",\n    params\n  });\n}\nfunction tsTypeParameterDeclaration(params) {\n  return (0, _validateNode.default)({\n    type: \"TSTypeParameterDeclaration\",\n    params\n  });\n}\nfunction tsTypeParameter() {\n  let constraint = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  let _default = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  let name = arguments.length > 2 ? arguments[2] : undefined;\n  return (0, _validateNode.default)({\n    type: \"TSTypeParameter\",\n    constraint,\n    default: _default,\n    name\n  });\n}\nfunction NumberLiteral(value) {\n  (0, _deprecationWarning.default)(\"NumberLiteral\", \"NumericLiteral\", \"The node type \");\n  return numericLiteral(value);\n}\nfunction RegexLiteral(pattern) {\n  let flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n  (0, _deprecationWarning.default)(\"RegexLiteral\", \"RegExpLiteral\", \"The node type \");\n  return regExpLiteral(pattern, flags);\n}\nfunction RestProperty(argument) {\n  (0, _deprecationWarning.default)(\"RestProperty\", \"RestElement\", \"The node type \");\n  return restElement(argument);\n}\nfunction SpreadProperty(argument) {\n  (0, _deprecationWarning.default)(\"SpreadProperty\", \"SpreadElement\", \"The node type \");\n  return spreadElement(argument);\n}","map":{"version":3,"names":["_validateNode","require","_deprecationWarning","arrayExpression","elements","arguments","length","undefined","default","type","assignmentExpression","operator","left","right","binaryExpression","interpreterDirective","value","directive","directiveLiteral","blockStatement","body","directives","breakStatement","label","callExpression","callee","_arguments","catchClause","param","conditionalExpression","test","consequent","alternate","continueStatement","debuggerStatement","doWhileStatement","emptyStatement","expressionStatement","expression","file","program","comments","tokens","forInStatement","forStatement","init","update","functionDeclaration","id","params","generator","async","functionExpression","identifier","name","ifStatement","labeledStatement","stringLiteral","numericLiteral","nullLiteral","booleanLiteral","regExpLiteral","pattern","flags","logicalExpression","memberExpression","object","property","computed","optional","newExpression","sourceType","interpreter","sourceFile","objectExpression","properties","objectMethod","kind","key","objectProperty","shorthand","decorators","restElement","argument","returnStatement","sequenceExpression","expressions","parenthesizedExpression","switchCase","switchStatement","discriminant","cases","thisExpression","throwStatement","tryStatement","block","handler","finalizer","unaryExpression","prefix","updateExpression","variableDeclaration","declarations","variableDeclarator","whileStatement","withStatement","assignmentPattern","arrayPattern","arrowFunctionExpression","classBody","classExpression","superClass","classDeclaration","exportAllDeclaration","source","exportDefaultDeclaration","declaration","exportNamedDeclaration","specifiers","exportSpecifier","local","exported","forOfStatement","_await","await","importDeclaration","importDefaultSpecifier","importNamespaceSpecifier","importSpecifier","imported","metaProperty","meta","classMethod","_static","static","objectPattern","spreadElement","_super","taggedTemplateExpression","tag","quasi","templateElement","tail","templateLiteral","quasis","yieldExpression","delegate","awaitExpression","_import","bigIntLiteral","exportNamespaceSpecifier","optionalMemberExpression","optionalCallExpression","classProperty","typeAnnotation","classAccessorProperty","classPrivateProperty","classPrivateMethod","privateName","staticBlock","anyTypeAnnotation","arrayTypeAnnotation","elementType","booleanTypeAnnotation","booleanLiteralTypeAnnotation","nullLiteralTypeAnnotation","classImplements","typeParameters","declareClass","_extends","extends","declareFunction","declareInterface","declareModule","declareModuleExports","declareTypeAlias","declareOpaqueType","supertype","declareVariable","declareExportDeclaration","declareExportAllDeclaration","declaredPredicate","existsTypeAnnotation","functionTypeAnnotation","rest","returnType","functionTypeParam","genericTypeAnnotation","inferredPredicate","interfaceExtends","interfaceDeclaration","interfaceTypeAnnotation","intersectionTypeAnnotation","types","mixedTypeAnnotation","emptyTypeAnnotation","nullableTypeAnnotation","numberLiteralTypeAnnotation","numberTypeAnnotation","objectTypeAnnotation","indexers","callProperties","internalSlots","exact","objectTypeInternalSlot","method","objectTypeCallProperty","objectTypeIndexer","variance","objectTypeProperty","proto","objectTypeSpreadProperty","opaqueType","impltype","qualifiedTypeIdentifier","qualification","stringLiteralTypeAnnotation","stringTypeAnnotation","symbolTypeAnnotation","thisTypeAnnotation","tupleTypeAnnotation","typeofTypeAnnotation","typeAlias","typeCastExpression","typeParameter","bound","_default","typeParameterDeclaration","typeParameterInstantiation","unionTypeAnnotation","voidTypeAnnotation","enumDeclaration","enumBooleanBody","members","explicitType","hasUnknownMembers","enumNumberBody","enumStringBody","enumSymbolBody","enumBooleanMember","enumNumberMember","enumStringMember","enumDefaultedMember","indexedAccessType","objectType","indexType","optionalIndexedAccessType","jsxAttribute","jsxClosingElement","jsxElement","openingElement","closingElement","children","selfClosing","jsxEmptyExpression","jsxExpressionContainer","jsxSpreadChild","jsxIdentifier","jsxMemberExpression","jsxNamespacedName","namespace","jsxOpeningElement","attributes","jsxSpreadAttribute","jsxText","jsxFragment","openingFragment","closingFragment","jsxOpeningFragment","jsxClosingFragment","noop","placeholder","expectedNode","v8IntrinsicIdentifier","argumentPlaceholder","bindExpression","importAttribute","decorator","doExpression","exportDefaultSpecifier","recordExpression","tupleExpression","decimalLiteral","moduleExpression","topicReference","pipelineTopicExpression","pipelineBareFunction","pipelinePrimaryTopicReference","tsParameterProperty","parameter","tsDeclareFunction","tsDeclareMethod","tsQualifiedName","tsCallSignatureDeclaration","parameters","tsConstructSignatureDeclaration","tsPropertySignature","initializer","tsMethodSignature","tsIndexSignature","tsAnyKeyword","tsBooleanKeyword","tsBigIntKeyword","tsIntrinsicKeyword","tsNeverKeyword","tsNullKeyword","tsNumberKeyword","tsObjectKeyword","tsStringKeyword","tsSymbolKeyword","tsUndefinedKeyword","tsUnknownKeyword","tsVoidKeyword","tsThisType","tsFunctionType","tsConstructorType","tsTypeReference","typeName","tsTypePredicate","parameterName","asserts","tsTypeQuery","exprName","tsTypeLiteral","tsArrayType","tsTupleType","elementTypes","tsOptionalType","tsRestType","tsNamedTupleMember","tsUnionType","tsIntersectionType","tsConditionalType","checkType","extendsType","trueType","falseType","tsInferType","tsParenthesizedType","tsTypeOperator","tsIndexedAccessType","tsMappedType","nameType","tsLiteralType","literal","tsExpressionWithTypeArguments","tsInterfaceDeclaration","tsInterfaceBody","tsTypeAliasDeclaration","tsInstantiationExpression","tsAsExpression","tsSatisfiesExpression","tsTypeAssertion","tsEnumDeclaration","tsEnumMember","tsModuleDeclaration","tsModuleBlock","tsImportType","qualifier","tsImportEqualsDeclaration","moduleReference","isExport","tsExternalModuleReference","tsNonNullExpression","tsExportAssignment","tsNamespaceExportDeclaration","tsTypeAnnotation","tsTypeParameterInstantiation","tsTypeParameterDeclaration","tsTypeParameter","constraint","NumberLiteral","RegexLiteral","RestProperty","SpreadProperty"],"sources":["C:\\Users\\8068programmer\\Documents\\GitHub\\leader-v3\\node_modules\\@babel\\types\\src\\builders\\generated\\index.ts"],"sourcesContent":["/*\n * This file is auto-generated! Do not modify it directly.\n * To re-generate run 'make build'\n */\nimport validateNode from \"../validateNode\";\nimport type * as t from \"../..\";\nimport deprecationWarning from \"../../utils/deprecationWarning\";\nexport function arrayExpression(\n  elements: Array<null | t.Expression | t.SpreadElement> = [],\n): t.ArrayExpression {\n  return validateNode<t.ArrayExpression>({\n    type: \"ArrayExpression\",\n    elements,\n  });\n}\nexport function assignmentExpression(\n  operator: string,\n  left: t.LVal,\n  right: t.Expression,\n): t.AssignmentExpression {\n  return validateNode<t.AssignmentExpression>({\n    type: \"AssignmentExpression\",\n    operator,\n    left,\n    right,\n  });\n}\nexport function binaryExpression(\n  operator:\n    | \"+\"\n    | \"-\"\n    | \"/\"\n    | \"%\"\n    | \"*\"\n    | \"**\"\n    | \"&\"\n    | \"|\"\n    | \">>\"\n    | \">>>\"\n    | \"<<\"\n    | \"^\"\n    | \"==\"\n    | \"===\"\n    | \"!=\"\n    | \"!==\"\n    | \"in\"\n    | \"instanceof\"\n    | \">\"\n    | \"<\"\n    | \">=\"\n    | \"<=\"\n    | \"|>\",\n  left: t.Expression | t.PrivateName,\n  right: t.Expression,\n): t.BinaryExpression {\n  return validateNode<t.BinaryExpression>({\n    type: \"BinaryExpression\",\n    operator,\n    left,\n    right,\n  });\n}\nexport function interpreterDirective(value: string): t.InterpreterDirective {\n  return validateNode<t.InterpreterDirective>({\n    type: \"InterpreterDirective\",\n    value,\n  });\n}\nexport function directive(value: t.DirectiveLiteral): t.Directive {\n  return validateNode<t.Directive>({\n    type: \"Directive\",\n    value,\n  });\n}\nexport function directiveLiteral(value: string): t.DirectiveLiteral {\n  return validateNode<t.DirectiveLiteral>({\n    type: \"DirectiveLiteral\",\n    value,\n  });\n}\nexport function blockStatement(\n  body: Array<t.Statement>,\n  directives: Array<t.Directive> = [],\n): t.BlockStatement {\n  return validateNode<t.BlockStatement>({\n    type: \"BlockStatement\",\n    body,\n    directives,\n  });\n}\nexport function breakStatement(\n  label: t.Identifier | null = null,\n): t.BreakStatement {\n  return validateNode<t.BreakStatement>({\n    type: \"BreakStatement\",\n    label,\n  });\n}\nexport function callExpression(\n  callee: t.Expression | t.Super | t.V8IntrinsicIdentifier,\n  _arguments: Array<\n    t.Expression | t.SpreadElement | t.JSXNamespacedName | t.ArgumentPlaceholder\n  >,\n): t.CallExpression {\n  return validateNode<t.CallExpression>({\n    type: \"CallExpression\",\n    callee,\n    arguments: _arguments,\n  });\n}\nexport function catchClause(\n  param:\n    | t.Identifier\n    | t.ArrayPattern\n    | t.ObjectPattern\n    | null\n    | undefined = null,\n  body: t.BlockStatement,\n): t.CatchClause {\n  return validateNode<t.CatchClause>({\n    type: \"CatchClause\",\n    param,\n    body,\n  });\n}\nexport function conditionalExpression(\n  test: t.Expression,\n  consequent: t.Expression,\n  alternate: t.Expression,\n): t.ConditionalExpression {\n  return validateNode<t.ConditionalExpression>({\n    type: \"ConditionalExpression\",\n    test,\n    consequent,\n    alternate,\n  });\n}\nexport function continueStatement(\n  label: t.Identifier | null = null,\n): t.ContinueStatement {\n  return validateNode<t.ContinueStatement>({\n    type: \"ContinueStatement\",\n    label,\n  });\n}\nexport function debuggerStatement(): t.DebuggerStatement {\n  return {\n    type: \"DebuggerStatement\",\n  };\n}\nexport function doWhileStatement(\n  test: t.Expression,\n  body: t.Statement,\n): t.DoWhileStatement {\n  return validateNode<t.DoWhileStatement>({\n    type: \"DoWhileStatement\",\n    test,\n    body,\n  });\n}\nexport function emptyStatement(): t.EmptyStatement {\n  return {\n    type: \"EmptyStatement\",\n  };\n}\nexport function expressionStatement(\n  expression: t.Expression,\n): t.ExpressionStatement {\n  return validateNode<t.ExpressionStatement>({\n    type: \"ExpressionStatement\",\n    expression,\n  });\n}\nexport function file(\n  program: t.Program,\n  comments: Array<t.CommentBlock | t.CommentLine> | null = null,\n  tokens: Array<any> | null = null,\n): t.File {\n  return validateNode<t.File>({\n    type: \"File\",\n    program,\n    comments,\n    tokens,\n  });\n}\nexport function forInStatement(\n  left: t.VariableDeclaration | t.LVal,\n  right: t.Expression,\n  body: t.Statement,\n): t.ForInStatement {\n  return validateNode<t.ForInStatement>({\n    type: \"ForInStatement\",\n    left,\n    right,\n    body,\n  });\n}\nexport function forStatement(\n  init: t.VariableDeclaration | t.Expression | null | undefined = null,\n  test: t.Expression | null | undefined = null,\n  update: t.Expression | null | undefined = null,\n  body: t.Statement,\n): t.ForStatement {\n  return validateNode<t.ForStatement>({\n    type: \"ForStatement\",\n    init,\n    test,\n    update,\n    body,\n  });\n}\nexport function functionDeclaration(\n  id: t.Identifier | null | undefined = null,\n  params: Array<t.Identifier | t.Pattern | t.RestElement>,\n  body: t.BlockStatement,\n  generator: boolean = false,\n  async: boolean = false,\n): t.FunctionDeclaration {\n  return validateNode<t.FunctionDeclaration>({\n    type: \"FunctionDeclaration\",\n    id,\n    params,\n    body,\n    generator,\n    async,\n  });\n}\nexport function functionExpression(\n  id: t.Identifier | null | undefined = null,\n  params: Array<t.Identifier | t.Pattern | t.RestElement>,\n  body: t.BlockStatement,\n  generator: boolean = false,\n  async: boolean = false,\n): t.FunctionExpression {\n  return validateNode<t.FunctionExpression>({\n    type: \"FunctionExpression\",\n    id,\n    params,\n    body,\n    generator,\n    async,\n  });\n}\nexport function identifier(name: string): t.Identifier {\n  return validateNode<t.Identifier>({\n    type: \"Identifier\",\n    name,\n  });\n}\nexport function ifStatement(\n  test: t.Expression,\n  consequent: t.Statement,\n  alternate: t.Statement | null = null,\n): t.IfStatement {\n  return validateNode<t.IfStatement>({\n    type: \"IfStatement\",\n    test,\n    consequent,\n    alternate,\n  });\n}\nexport function labeledStatement(\n  label: t.Identifier,\n  body: t.Statement,\n): t.LabeledStatement {\n  return validateNode<t.LabeledStatement>({\n    type: \"LabeledStatement\",\n    label,\n    body,\n  });\n}\nexport function stringLiteral(value: string): t.StringLiteral {\n  return validateNode<t.StringLiteral>({\n    type: \"StringLiteral\",\n    value,\n  });\n}\nexport function numericLiteral(value: number): t.NumericLiteral {\n  return validateNode<t.NumericLiteral>({\n    type: \"NumericLiteral\",\n    value,\n  });\n}\nexport function nullLiteral(): t.NullLiteral {\n  return {\n    type: \"NullLiteral\",\n  };\n}\nexport function booleanLiteral(value: boolean): t.BooleanLiteral {\n  return validateNode<t.BooleanLiteral>({\n    type: \"BooleanLiteral\",\n    value,\n  });\n}\nexport function regExpLiteral(\n  pattern: string,\n  flags: string = \"\",\n): t.RegExpLiteral {\n  return validateNode<t.RegExpLiteral>({\n    type: \"RegExpLiteral\",\n    pattern,\n    flags,\n  });\n}\nexport function logicalExpression(\n  operator: \"||\" | \"&&\" | \"??\",\n  left: t.Expression,\n  right: t.Expression,\n): t.LogicalExpression {\n  return validateNode<t.LogicalExpression>({\n    type: \"LogicalExpression\",\n    operator,\n    left,\n    right,\n  });\n}\nexport function memberExpression(\n  object: t.Expression | t.Super,\n  property: t.Expression | t.Identifier | t.PrivateName,\n  computed: boolean = false,\n  optional: true | false | null = null,\n): t.MemberExpression {\n  return validateNode<t.MemberExpression>({\n    type: \"MemberExpression\",\n    object,\n    property,\n    computed,\n    optional,\n  });\n}\nexport function newExpression(\n  callee: t.Expression | t.Super | t.V8IntrinsicIdentifier,\n  _arguments: Array<\n    t.Expression | t.SpreadElement | t.JSXNamespacedName | t.ArgumentPlaceholder\n  >,\n): t.NewExpression {\n  return validateNode<t.NewExpression>({\n    type: \"NewExpression\",\n    callee,\n    arguments: _arguments,\n  });\n}\nexport function program(\n  body: Array<t.Statement>,\n  directives: Array<t.Directive> = [],\n  sourceType: \"script\" | \"module\" = \"script\",\n  interpreter: t.InterpreterDirective | null = null,\n): t.Program {\n  return validateNode<t.Program>({\n    type: \"Program\",\n    body,\n    directives,\n    sourceType,\n    interpreter,\n    sourceFile: null,\n  });\n}\nexport function objectExpression(\n  properties: Array<t.ObjectMethod | t.ObjectProperty | t.SpreadElement>,\n): t.ObjectExpression {\n  return validateNode<t.ObjectExpression>({\n    type: \"ObjectExpression\",\n    properties,\n  });\n}\nexport function objectMethod(\n  kind: \"method\" | \"get\" | \"set\" | undefined = \"method\",\n  key:\n    | t.Expression\n    | t.Identifier\n    | t.StringLiteral\n    | t.NumericLiteral\n    | t.BigIntLiteral,\n  params: Array<t.Identifier | t.Pattern | t.RestElement>,\n  body: t.BlockStatement,\n  computed: boolean = false,\n  generator: boolean = false,\n  async: boolean = false,\n): t.ObjectMethod {\n  return validateNode<t.ObjectMethod>({\n    type: \"ObjectMethod\",\n    kind,\n    key,\n    params,\n    body,\n    computed,\n    generator,\n    async,\n  });\n}\nexport function objectProperty(\n  key:\n    | t.Expression\n    | t.Identifier\n    | t.StringLiteral\n    | t.NumericLiteral\n    | t.BigIntLiteral\n    | t.DecimalLiteral\n    | t.PrivateName,\n  value: t.Expression | t.PatternLike,\n  computed: boolean = false,\n  shorthand: boolean = false,\n  decorators: Array<t.Decorator> | null = null,\n): t.ObjectProperty {\n  return validateNode<t.ObjectProperty>({\n    type: \"ObjectProperty\",\n    key,\n    value,\n    computed,\n    shorthand,\n    decorators,\n  });\n}\nexport function restElement(argument: t.LVal): t.RestElement {\n  return validateNode<t.RestElement>({\n    type: \"RestElement\",\n    argument,\n  });\n}\nexport function returnStatement(\n  argument: t.Expression | null = null,\n): t.ReturnStatement {\n  return validateNode<t.ReturnStatement>({\n    type: \"ReturnStatement\",\n    argument,\n  });\n}\nexport function sequenceExpression(\n  expressions: Array<t.Expression>,\n): t.SequenceExpression {\n  return validateNode<t.SequenceExpression>({\n    type: \"SequenceExpression\",\n    expressions,\n  });\n}\nexport function parenthesizedExpression(\n  expression: t.Expression,\n): t.ParenthesizedExpression {\n  return validateNode<t.ParenthesizedExpression>({\n    type: \"ParenthesizedExpression\",\n    expression,\n  });\n}\nexport function switchCase(\n  test: t.Expression | null | undefined = null,\n  consequent: Array<t.Statement>,\n): t.SwitchCase {\n  return validateNode<t.SwitchCase>({\n    type: \"SwitchCase\",\n    test,\n    consequent,\n  });\n}\nexport function switchStatement(\n  discriminant: t.Expression,\n  cases: Array<t.SwitchCase>,\n): t.SwitchStatement {\n  return validateNode<t.SwitchStatement>({\n    type: \"SwitchStatement\",\n    discriminant,\n    cases,\n  });\n}\nexport function thisExpression(): t.ThisExpression {\n  return {\n    type: \"ThisExpression\",\n  };\n}\nexport function throwStatement(argument: t.Expression): t.ThrowStatement {\n  return validateNode<t.ThrowStatement>({\n    type: \"ThrowStatement\",\n    argument,\n  });\n}\nexport function tryStatement(\n  block: t.BlockStatement,\n  handler: t.CatchClause | null = null,\n  finalizer: t.BlockStatement | null = null,\n): t.TryStatement {\n  return validateNode<t.TryStatement>({\n    type: \"TryStatement\",\n    block,\n    handler,\n    finalizer,\n  });\n}\nexport function unaryExpression(\n  operator: \"void\" | \"throw\" | \"delete\" | \"!\" | \"+\" | \"-\" | \"~\" | \"typeof\",\n  argument: t.Expression,\n  prefix: boolean = true,\n): t.UnaryExpression {\n  return validateNode<t.UnaryExpression>({\n    type: \"UnaryExpression\",\n    operator,\n    argument,\n    prefix,\n  });\n}\nexport function updateExpression(\n  operator: \"++\" | \"--\",\n  argument: t.Expression,\n  prefix: boolean = false,\n): t.UpdateExpression {\n  return validateNode<t.UpdateExpression>({\n    type: \"UpdateExpression\",\n    operator,\n    argument,\n    prefix,\n  });\n}\nexport function variableDeclaration(\n  kind: \"var\" | \"let\" | \"const\" | \"using\",\n  declarations: Array<t.VariableDeclarator>,\n): t.VariableDeclaration {\n  return validateNode<t.VariableDeclaration>({\n    type: \"VariableDeclaration\",\n    kind,\n    declarations,\n  });\n}\nexport function variableDeclarator(\n  id: t.LVal,\n  init: t.Expression | null = null,\n): t.VariableDeclarator {\n  return validateNode<t.VariableDeclarator>({\n    type: \"VariableDeclarator\",\n    id,\n    init,\n  });\n}\nexport function whileStatement(\n  test: t.Expression,\n  body: t.Statement,\n): t.WhileStatement {\n  return validateNode<t.WhileStatement>({\n    type: \"WhileStatement\",\n    test,\n    body,\n  });\n}\nexport function withStatement(\n  object: t.Expression,\n  body: t.Statement,\n): t.WithStatement {\n  return validateNode<t.WithStatement>({\n    type: \"WithStatement\",\n    object,\n    body,\n  });\n}\nexport function assignmentPattern(\n  left:\n    | t.Identifier\n    | t.ObjectPattern\n    | t.ArrayPattern\n    | t.MemberExpression\n    | t.TSAsExpression\n    | t.TSSatisfiesExpression\n    | t.TSTypeAssertion\n    | t.TSNonNullExpression,\n  right: t.Expression,\n): t.AssignmentPattern {\n  return validateNode<t.AssignmentPattern>({\n    type: \"AssignmentPattern\",\n    left,\n    right,\n  });\n}\nexport function arrayPattern(\n  elements: Array<null | t.PatternLike | t.LVal>,\n): t.ArrayPattern {\n  return validateNode<t.ArrayPattern>({\n    type: \"ArrayPattern\",\n    elements,\n  });\n}\nexport function arrowFunctionExpression(\n  params: Array<t.Identifier | t.Pattern | t.RestElement>,\n  body: t.BlockStatement | t.Expression,\n  async: boolean = false,\n): t.ArrowFunctionExpression {\n  return validateNode<t.ArrowFunctionExpression>({\n    type: \"ArrowFunctionExpression\",\n    params,\n    body,\n    async,\n    expression: null,\n  });\n}\nexport function classBody(\n  body: Array<\n    | t.ClassMethod\n    | t.ClassPrivateMethod\n    | t.ClassProperty\n    | t.ClassPrivateProperty\n    | t.ClassAccessorProperty\n    | t.TSDeclareMethod\n    | t.TSIndexSignature\n    | t.StaticBlock\n  >,\n): t.ClassBody {\n  return validateNode<t.ClassBody>({\n    type: \"ClassBody\",\n    body,\n  });\n}\nexport function classExpression(\n  id: t.Identifier | null | undefined = null,\n  superClass: t.Expression | null | undefined = null,\n  body: t.ClassBody,\n  decorators: Array<t.Decorator> | null = null,\n): t.ClassExpression {\n  return validateNode<t.ClassExpression>({\n    type: \"ClassExpression\",\n    id,\n    superClass,\n    body,\n    decorators,\n  });\n}\nexport function classDeclaration(\n  id: t.Identifier,\n  superClass: t.Expression | null | undefined = null,\n  body: t.ClassBody,\n  decorators: Array<t.Decorator> | null = null,\n): t.ClassDeclaration {\n  return validateNode<t.ClassDeclaration>({\n    type: \"ClassDeclaration\",\n    id,\n    superClass,\n    body,\n    decorators,\n  });\n}\nexport function exportAllDeclaration(\n  source: t.StringLiteral,\n): t.ExportAllDeclaration {\n  return validateNode<t.ExportAllDeclaration>({\n    type: \"ExportAllDeclaration\",\n    source,\n  });\n}\nexport function exportDefaultDeclaration(\n  declaration:\n    | t.TSDeclareFunction\n    | t.FunctionDeclaration\n    | t.ClassDeclaration\n    | t.Expression,\n): t.ExportDefaultDeclaration {\n  return validateNode<t.ExportDefaultDeclaration>({\n    type: \"ExportDefaultDeclaration\",\n    declaration,\n  });\n}\nexport function exportNamedDeclaration(\n  declaration: t.Declaration | null = null,\n  specifiers: Array<\n    t.ExportSpecifier | t.ExportDefaultSpecifier | t.ExportNamespaceSpecifier\n  > = [],\n  source: t.StringLiteral | null = null,\n): t.ExportNamedDeclaration {\n  return validateNode<t.ExportNamedDeclaration>({\n    type: \"ExportNamedDeclaration\",\n    declaration,\n    specifiers,\n    source,\n  });\n}\nexport function exportSpecifier(\n  local: t.Identifier,\n  exported: t.Identifier | t.StringLiteral,\n): t.ExportSpecifier {\n  return validateNode<t.ExportSpecifier>({\n    type: \"ExportSpecifier\",\n    local,\n    exported,\n  });\n}\nexport function forOfStatement(\n  left: t.VariableDeclaration | t.LVal,\n  right: t.Expression,\n  body: t.Statement,\n  _await: boolean = false,\n): t.ForOfStatement {\n  return validateNode<t.ForOfStatement>({\n    type: \"ForOfStatement\",\n    left,\n    right,\n    body,\n    await: _await,\n  });\n}\nexport function importDeclaration(\n  specifiers: Array<\n    t.ImportSpecifier | t.ImportDefaultSpecifier | t.ImportNamespaceSpecifier\n  >,\n  source: t.StringLiteral,\n): t.ImportDeclaration {\n  return validateNode<t.ImportDeclaration>({\n    type: \"ImportDeclaration\",\n    specifiers,\n    source,\n  });\n}\nexport function importDefaultSpecifier(\n  local: t.Identifier,\n): t.ImportDefaultSpecifier {\n  return validateNode<t.ImportDefaultSpecifier>({\n    type: \"ImportDefaultSpecifier\",\n    local,\n  });\n}\nexport function importNamespaceSpecifier(\n  local: t.Identifier,\n): t.ImportNamespaceSpecifier {\n  return validateNode<t.ImportNamespaceSpecifier>({\n    type: \"ImportNamespaceSpecifier\",\n    local,\n  });\n}\nexport function importSpecifier(\n  local: t.Identifier,\n  imported: t.Identifier | t.StringLiteral,\n): t.ImportSpecifier {\n  return validateNode<t.ImportSpecifier>({\n    type: \"ImportSpecifier\",\n    local,\n    imported,\n  });\n}\nexport function metaProperty(\n  meta: t.Identifier,\n  property: t.Identifier,\n): t.MetaProperty {\n  return validateNode<t.MetaProperty>({\n    type: \"MetaProperty\",\n    meta,\n    property,\n  });\n}\nexport function classMethod(\n  kind: \"get\" | \"set\" | \"method\" | \"constructor\" | undefined = \"method\",\n  key:\n    | t.Identifier\n    | t.StringLiteral\n    | t.NumericLiteral\n    | t.BigIntLiteral\n    | t.Expression,\n  params: Array<\n    t.Identifier | t.Pattern | t.RestElement | t.TSParameterProperty\n  >,\n  body: t.BlockStatement,\n  computed: boolean = false,\n  _static: boolean = false,\n  generator: boolean = false,\n  async: boolean = false,\n): t.ClassMethod {\n  return validateNode<t.ClassMethod>({\n    type: \"ClassMethod\",\n    kind,\n    key,\n    params,\n    body,\n    computed,\n    static: _static,\n    generator,\n    async,\n  });\n}\nexport function objectPattern(\n  properties: Array<t.RestElement | t.ObjectProperty>,\n): t.ObjectPattern {\n  return validateNode<t.ObjectPattern>({\n    type: \"ObjectPattern\",\n    properties,\n  });\n}\nexport function spreadElement(argument: t.Expression): t.SpreadElement {\n  return validateNode<t.SpreadElement>({\n    type: \"SpreadElement\",\n    argument,\n  });\n}\nfunction _super(): t.Super {\n  return {\n    type: \"Super\",\n  };\n}\nexport { _super as super };\nexport function taggedTemplateExpression(\n  tag: t.Expression,\n  quasi: t.TemplateLiteral,\n): t.TaggedTemplateExpression {\n  return validateNode<t.TaggedTemplateExpression>({\n    type: \"TaggedTemplateExpression\",\n    tag,\n    quasi,\n  });\n}\nexport function templateElement(\n  value: { raw: string; cooked?: string },\n  tail: boolean = false,\n): t.TemplateElement {\n  return validateNode<t.TemplateElement>({\n    type: \"TemplateElement\",\n    value,\n    tail,\n  });\n}\nexport function templateLiteral(\n  quasis: Array<t.TemplateElement>,\n  expressions: Array<t.Expression | t.TSType>,\n): t.TemplateLiteral {\n  return validateNode<t.TemplateLiteral>({\n    type: \"TemplateLiteral\",\n    quasis,\n    expressions,\n  });\n}\nexport function yieldExpression(\n  argument: t.Expression | null = null,\n  delegate: boolean = false,\n): t.YieldExpression {\n  return validateNode<t.YieldExpression>({\n    type: \"YieldExpression\",\n    argument,\n    delegate,\n  });\n}\nexport function awaitExpression(argument: t.Expression): t.AwaitExpression {\n  return validateNode<t.AwaitExpression>({\n    type: \"AwaitExpression\",\n    argument,\n  });\n}\nfunction _import(): t.Import {\n  return {\n    type: \"Import\",\n  };\n}\nexport { _import as import };\nexport function bigIntLiteral(value: string): t.BigIntLiteral {\n  return validateNode<t.BigIntLiteral>({\n    type: \"BigIntLiteral\",\n    value,\n  });\n}\nexport function exportNamespaceSpecifier(\n  exported: t.Identifier,\n): t.ExportNamespaceSpecifier {\n  return validateNode<t.ExportNamespaceSpecifier>({\n    type: \"ExportNamespaceSpecifier\",\n    exported,\n  });\n}\nexport function optionalMemberExpression(\n  object: t.Expression,\n  property: t.Expression | t.Identifier,\n  computed: boolean | undefined = false,\n  optional: boolean,\n): t.OptionalMemberExpression {\n  return validateNode<t.OptionalMemberExpression>({\n    type: \"OptionalMemberExpression\",\n    object,\n    property,\n    computed,\n    optional,\n  });\n}\nexport function optionalCallExpression(\n  callee: t.Expression,\n  _arguments: Array<\n    t.Expression | t.SpreadElement | t.JSXNamespacedName | t.ArgumentPlaceholder\n  >,\n  optional: boolean,\n): t.OptionalCallExpression {\n  return validateNode<t.OptionalCallExpression>({\n    type: \"OptionalCallExpression\",\n    callee,\n    arguments: _arguments,\n    optional,\n  });\n}\nexport function classProperty(\n  key:\n    | t.Identifier\n    | t.StringLiteral\n    | t.NumericLiteral\n    | t.BigIntLiteral\n    | t.Expression,\n  value: t.Expression | null = null,\n  typeAnnotation: t.TypeAnnotation | t.TSTypeAnnotation | t.Noop | null = null,\n  decorators: Array<t.Decorator> | null = null,\n  computed: boolean = false,\n  _static: boolean = false,\n): t.ClassProperty {\n  return validateNode<t.ClassProperty>({\n    type: \"ClassProperty\",\n    key,\n    value,\n    typeAnnotation,\n    decorators,\n    computed,\n    static: _static,\n  });\n}\nexport function classAccessorProperty(\n  key:\n    | t.Identifier\n    | t.StringLiteral\n    | t.NumericLiteral\n    | t.BigIntLiteral\n    | t.Expression\n    | t.PrivateName,\n  value: t.Expression | null = null,\n  typeAnnotation: t.TypeAnnotation | t.TSTypeAnnotation | t.Noop | null = null,\n  decorators: Array<t.Decorator> | null = null,\n  computed: boolean = false,\n  _static: boolean = false,\n): t.ClassAccessorProperty {\n  return validateNode<t.ClassAccessorProperty>({\n    type: \"ClassAccessorProperty\",\n    key,\n    value,\n    typeAnnotation,\n    decorators,\n    computed,\n    static: _static,\n  });\n}\nexport function classPrivateProperty(\n  key: t.PrivateName,\n  value: t.Expression | null = null,\n  decorators: Array<t.Decorator> | null = null,\n  _static: boolean = false,\n): t.ClassPrivateProperty {\n  return validateNode<t.ClassPrivateProperty>({\n    type: \"ClassPrivateProperty\",\n    key,\n    value,\n    decorators,\n    static: _static,\n  });\n}\nexport function classPrivateMethod(\n  kind: \"get\" | \"set\" | \"method\" | undefined = \"method\",\n  key: t.PrivateName,\n  params: Array<\n    t.Identifier | t.Pattern | t.RestElement | t.TSParameterProperty\n  >,\n  body: t.BlockStatement,\n  _static: boolean = false,\n): t.ClassPrivateMethod {\n  return validateNode<t.ClassPrivateMethod>({\n    type: \"ClassPrivateMethod\",\n    kind,\n    key,\n    params,\n    body,\n    static: _static,\n  });\n}\nexport function privateName(id: t.Identifier): t.PrivateName {\n  return validateNode<t.PrivateName>({\n    type: \"PrivateName\",\n    id,\n  });\n}\nexport function staticBlock(body: Array<t.Statement>): t.StaticBlock {\n  return validateNode<t.StaticBlock>({\n    type: \"StaticBlock\",\n    body,\n  });\n}\nexport function anyTypeAnnotation(): t.AnyTypeAnnotation {\n  return {\n    type: \"AnyTypeAnnotation\",\n  };\n}\nexport function arrayTypeAnnotation(\n  elementType: t.FlowType,\n): t.ArrayTypeAnnotation {\n  return validateNode<t.ArrayTypeAnnotation>({\n    type: \"ArrayTypeAnnotation\",\n    elementType,\n  });\n}\nexport function booleanTypeAnnotation(): t.BooleanTypeAnnotation {\n  return {\n    type: \"BooleanTypeAnnotation\",\n  };\n}\nexport function booleanLiteralTypeAnnotation(\n  value: boolean,\n): t.BooleanLiteralTypeAnnotation {\n  return validateNode<t.BooleanLiteralTypeAnnotation>({\n    type: \"BooleanLiteralTypeAnnotation\",\n    value,\n  });\n}\nexport function nullLiteralTypeAnnotation(): t.NullLiteralTypeAnnotation {\n  return {\n    type: \"NullLiteralTypeAnnotation\",\n  };\n}\nexport function classImplements(\n  id: t.Identifier,\n  typeParameters: t.TypeParameterInstantiation | null = null,\n): t.ClassImplements {\n  return validateNode<t.ClassImplements>({\n    type: \"ClassImplements\",\n    id,\n    typeParameters,\n  });\n}\nexport function declareClass(\n  id: t.Identifier,\n  typeParameters: t.TypeParameterDeclaration | null | undefined = null,\n  _extends: Array<t.InterfaceExtends> | null | undefined = null,\n  body: t.ObjectTypeAnnotation,\n): t.DeclareClass {\n  return validateNode<t.DeclareClass>({\n    type: \"DeclareClass\",\n    id,\n    typeParameters,\n    extends: _extends,\n    body,\n  });\n}\nexport function declareFunction(id: t.Identifier): t.DeclareFunction {\n  return validateNode<t.DeclareFunction>({\n    type: \"DeclareFunction\",\n    id,\n  });\n}\nexport function declareInterface(\n  id: t.Identifier,\n  typeParameters: t.TypeParameterDeclaration | null | undefined = null,\n  _extends: Array<t.InterfaceExtends> | null | undefined = null,\n  body: t.ObjectTypeAnnotation,\n): t.DeclareInterface {\n  return validateNode<t.DeclareInterface>({\n    type: \"DeclareInterface\",\n    id,\n    typeParameters,\n    extends: _extends,\n    body,\n  });\n}\nexport function declareModule(\n  id: t.Identifier | t.StringLiteral,\n  body: t.BlockStatement,\n  kind: \"CommonJS\" | \"ES\" | null = null,\n): t.DeclareModule {\n  return validateNode<t.DeclareModule>({\n    type: \"DeclareModule\",\n    id,\n    body,\n    kind,\n  });\n}\nexport function declareModuleExports(\n  typeAnnotation: t.TypeAnnotation,\n): t.DeclareModuleExports {\n  return validateNode<t.DeclareModuleExports>({\n    type: \"DeclareModuleExports\",\n    typeAnnotation,\n  });\n}\nexport function declareTypeAlias(\n  id: t.Identifier,\n  typeParameters: t.TypeParameterDeclaration | null | undefined = null,\n  right: t.FlowType,\n): t.DeclareTypeAlias {\n  return validateNode<t.DeclareTypeAlias>({\n    type: \"DeclareTypeAlias\",\n    id,\n    typeParameters,\n    right,\n  });\n}\nexport function declareOpaqueType(\n  id: t.Identifier,\n  typeParameters: t.TypeParameterDeclaration | null = null,\n  supertype: t.FlowType | null = null,\n): t.DeclareOpaqueType {\n  return validateNode<t.DeclareOpaqueType>({\n    type: \"DeclareOpaqueType\",\n    id,\n    typeParameters,\n    supertype,\n  });\n}\nexport function declareVariable(id: t.Identifier): t.DeclareVariable {\n  return validateNode<t.DeclareVariable>({\n    type: \"DeclareVariable\",\n    id,\n  });\n}\nexport function declareExportDeclaration(\n  declaration: t.Flow | null = null,\n  specifiers: Array<\n    t.ExportSpecifier | t.ExportNamespaceSpecifier\n  > | null = null,\n  source: t.StringLiteral | null = null,\n): t.DeclareExportDeclaration {\n  return validateNode<t.DeclareExportDeclaration>({\n    type: \"DeclareExportDeclaration\",\n    declaration,\n    specifiers,\n    source,\n  });\n}\nexport function declareExportAllDeclaration(\n  source: t.StringLiteral,\n): t.DeclareExportAllDeclaration {\n  return validateNode<t.DeclareExportAllDeclaration>({\n    type: \"DeclareExportAllDeclaration\",\n    source,\n  });\n}\nexport function declaredPredicate(value: t.Flow): t.DeclaredPredicate {\n  return validateNode<t.DeclaredPredicate>({\n    type: \"DeclaredPredicate\",\n    value,\n  });\n}\nexport function existsTypeAnnotation(): t.ExistsTypeAnnotation {\n  return {\n    type: \"ExistsTypeAnnotation\",\n  };\n}\nexport function functionTypeAnnotation(\n  typeParameters: t.TypeParameterDeclaration | null | undefined = null,\n  params: Array<t.FunctionTypeParam>,\n  rest: t.FunctionTypeParam | null | undefined = null,\n  returnType: t.FlowType,\n): t.FunctionTypeAnnotation {\n  return validateNode<t.FunctionTypeAnnotation>({\n    type: \"FunctionTypeAnnotation\",\n    typeParameters,\n    params,\n    rest,\n    returnType,\n  });\n}\nexport function functionTypeParam(\n  name: t.Identifier | null | undefined = null,\n  typeAnnotation: t.FlowType,\n): t.FunctionTypeParam {\n  return validateNode<t.FunctionTypeParam>({\n    type: \"FunctionTypeParam\",\n    name,\n    typeAnnotation,\n  });\n}\nexport function genericTypeAnnotation(\n  id: t.Identifier | t.QualifiedTypeIdentifier,\n  typeParameters: t.TypeParameterInstantiation | null = null,\n): t.GenericTypeAnnotation {\n  return validateNode<t.GenericTypeAnnotation>({\n    type: \"GenericTypeAnnotation\",\n    id,\n    typeParameters,\n  });\n}\nexport function inferredPredicate(): t.InferredPredicate {\n  return {\n    type: \"InferredPredicate\",\n  };\n}\nexport function interfaceExtends(\n  id: t.Identifier | t.QualifiedTypeIdentifier,\n  typeParameters: t.TypeParameterInstantiation | null = null,\n): t.InterfaceExtends {\n  return validateNode<t.InterfaceExtends>({\n    type: \"InterfaceExtends\",\n    id,\n    typeParameters,\n  });\n}\nexport function interfaceDeclaration(\n  id: t.Identifier,\n  typeParameters: t.TypeParameterDeclaration | null | undefined = null,\n  _extends: Array<t.InterfaceExtends> | null | undefined = null,\n  body: t.ObjectTypeAnnotation,\n): t.InterfaceDeclaration {\n  return validateNode<t.InterfaceDeclaration>({\n    type: \"InterfaceDeclaration\",\n    id,\n    typeParameters,\n    extends: _extends,\n    body,\n  });\n}\nexport function interfaceTypeAnnotation(\n  _extends: Array<t.InterfaceExtends> | null | undefined = null,\n  body: t.ObjectTypeAnnotation,\n): t.InterfaceTypeAnnotation {\n  return validateNode<t.InterfaceTypeAnnotation>({\n    type: \"InterfaceTypeAnnotation\",\n    extends: _extends,\n    body,\n  });\n}\nexport function intersectionTypeAnnotation(\n  types: Array<t.FlowType>,\n): t.IntersectionTypeAnnotation {\n  return validateNode<t.IntersectionTypeAnnotation>({\n    type: \"IntersectionTypeAnnotation\",\n    types,\n  });\n}\nexport function mixedTypeAnnotation(): t.MixedTypeAnnotation {\n  return {\n    type: \"MixedTypeAnnotation\",\n  };\n}\nexport function emptyTypeAnnotation(): t.EmptyTypeAnnotation {\n  return {\n    type: \"EmptyTypeAnnotation\",\n  };\n}\nexport function nullableTypeAnnotation(\n  typeAnnotation: t.FlowType,\n): t.NullableTypeAnnotation {\n  return validateNode<t.NullableTypeAnnotation>({\n    type: \"NullableTypeAnnotation\",\n    typeAnnotation,\n  });\n}\nexport function numberLiteralTypeAnnotation(\n  value: number,\n): t.NumberLiteralTypeAnnotation {\n  return validateNode<t.NumberLiteralTypeAnnotation>({\n    type: \"NumberLiteralTypeAnnotation\",\n    value,\n  });\n}\nexport function numberTypeAnnotation(): t.NumberTypeAnnotation {\n  return {\n    type: \"NumberTypeAnnotation\",\n  };\n}\nexport function objectTypeAnnotation(\n  properties: Array<t.ObjectTypeProperty | t.ObjectTypeSpreadProperty>,\n  indexers: Array<t.ObjectTypeIndexer> = [],\n  callProperties: Array<t.ObjectTypeCallProperty> = [],\n  internalSlots: Array<t.ObjectTypeInternalSlot> = [],\n  exact: boolean = false,\n): t.ObjectTypeAnnotation {\n  return validateNode<t.ObjectTypeAnnotation>({\n    type: \"ObjectTypeAnnotation\",\n    properties,\n    indexers,\n    callProperties,\n    internalSlots,\n    exact,\n  });\n}\nexport function objectTypeInternalSlot(\n  id: t.Identifier,\n  value: t.FlowType,\n  optional: boolean,\n  _static: boolean,\n  method: boolean,\n): t.ObjectTypeInternalSlot {\n  return validateNode<t.ObjectTypeInternalSlot>({\n    type: \"ObjectTypeInternalSlot\",\n    id,\n    value,\n    optional,\n    static: _static,\n    method,\n  });\n}\nexport function objectTypeCallProperty(\n  value: t.FlowType,\n): t.ObjectTypeCallProperty {\n  return validateNode<t.ObjectTypeCallProperty>({\n    type: \"ObjectTypeCallProperty\",\n    value,\n    static: null,\n  });\n}\nexport function objectTypeIndexer(\n  id: t.Identifier | null | undefined = null,\n  key: t.FlowType,\n  value: t.FlowType,\n  variance: t.Variance | null = null,\n): t.ObjectTypeIndexer {\n  return validateNode<t.ObjectTypeIndexer>({\n    type: \"ObjectTypeIndexer\",\n    id,\n    key,\n    value,\n    variance,\n    static: null,\n  });\n}\nexport function objectTypeProperty(\n  key: t.Identifier | t.StringLiteral,\n  value: t.FlowType,\n  variance: t.Variance | null = null,\n): t.ObjectTypeProperty {\n  return validateNode<t.ObjectTypeProperty>({\n    type: \"ObjectTypeProperty\",\n    key,\n    value,\n    variance,\n    kind: null,\n    method: null,\n    optional: null,\n    proto: null,\n    static: null,\n  });\n}\nexport function objectTypeSpreadProperty(\n  argument: t.FlowType,\n): t.ObjectTypeSpreadProperty {\n  return validateNode<t.ObjectTypeSpreadProperty>({\n    type: \"ObjectTypeSpreadProperty\",\n    argument,\n  });\n}\nexport function opaqueType(\n  id: t.Identifier,\n  typeParameters: t.TypeParameterDeclaration | null | undefined = null,\n  supertype: t.FlowType | null | undefined = null,\n  impltype: t.FlowType,\n): t.OpaqueType {\n  return validateNode<t.OpaqueType>({\n    type: \"OpaqueType\",\n    id,\n    typeParameters,\n    supertype,\n    impltype,\n  });\n}\nexport function qualifiedTypeIdentifier(\n  id: t.Identifier,\n  qualification: t.Identifier | t.QualifiedTypeIdentifier,\n): t.QualifiedTypeIdentifier {\n  return validateNode<t.QualifiedTypeIdentifier>({\n    type: \"QualifiedTypeIdentifier\",\n    id,\n    qualification,\n  });\n}\nexport function stringLiteralTypeAnnotation(\n  value: string,\n): t.StringLiteralTypeAnnotation {\n  return validateNode<t.StringLiteralTypeAnnotation>({\n    type: \"StringLiteralTypeAnnotation\",\n    value,\n  });\n}\nexport function stringTypeAnnotation(): t.StringTypeAnnotation {\n  return {\n    type: \"StringTypeAnnotation\",\n  };\n}\nexport function symbolTypeAnnotation(): t.SymbolTypeAnnotation {\n  return {\n    type: \"SymbolTypeAnnotation\",\n  };\n}\nexport function thisTypeAnnotation(): t.ThisTypeAnnotation {\n  return {\n    type: \"ThisTypeAnnotation\",\n  };\n}\nexport function tupleTypeAnnotation(\n  types: Array<t.FlowType>,\n): t.TupleTypeAnnotation {\n  return validateNode<t.TupleTypeAnnotation>({\n    type: \"TupleTypeAnnotation\",\n    types,\n  });\n}\nexport function typeofTypeAnnotation(\n  argument: t.FlowType,\n): t.TypeofTypeAnnotation {\n  return validateNode<t.TypeofTypeAnnotation>({\n    type: \"TypeofTypeAnnotation\",\n    argument,\n  });\n}\nexport function typeAlias(\n  id: t.Identifier,\n  typeParameters: t.TypeParameterDeclaration | null | undefined = null,\n  right: t.FlowType,\n): t.TypeAlias {\n  return validateNode<t.TypeAlias>({\n    type: \"TypeAlias\",\n    id,\n    typeParameters,\n    right,\n  });\n}\nexport function typeAnnotation(typeAnnotation: t.FlowType): t.TypeAnnotation {\n  return validateNode<t.TypeAnnotation>({\n    type: \"TypeAnnotation\",\n    typeAnnotation,\n  });\n}\nexport function typeCastExpression(\n  expression: t.Expression,\n  typeAnnotation: t.TypeAnnotation,\n): t.TypeCastExpression {\n  return validateNode<t.TypeCastExpression>({\n    type: \"TypeCastExpression\",\n    expression,\n    typeAnnotation,\n  });\n}\nexport function typeParameter(\n  bound: t.TypeAnnotation | null = null,\n  _default: t.FlowType | null = null,\n  variance: t.Variance | null = null,\n): t.TypeParameter {\n  return validateNode<t.TypeParameter>({\n    type: \"TypeParameter\",\n    bound,\n    default: _default,\n    variance,\n    name: null,\n  });\n}\nexport function typeParameterDeclaration(\n  params: Array<t.TypeParameter>,\n): t.TypeParameterDeclaration {\n  return validateNode<t.TypeParameterDeclaration>({\n    type: \"TypeParameterDeclaration\",\n    params,\n  });\n}\nexport function typeParameterInstantiation(\n  params: Array<t.FlowType>,\n): t.TypeParameterInstantiation {\n  return validateNode<t.TypeParameterInstantiation>({\n    type: \"TypeParameterInstantiation\",\n    params,\n  });\n}\nexport function unionTypeAnnotation(\n  types: Array<t.FlowType>,\n): t.UnionTypeAnnotation {\n  return validateNode<t.UnionTypeAnnotation>({\n    type: \"UnionTypeAnnotation\",\n    types,\n  });\n}\nexport function variance(kind: \"minus\" | \"plus\"): t.Variance {\n  return validateNode<t.Variance>({\n    type: \"Variance\",\n    kind,\n  });\n}\nexport function voidTypeAnnotation(): t.VoidTypeAnnotation {\n  return {\n    type: \"VoidTypeAnnotation\",\n  };\n}\nexport function enumDeclaration(\n  id: t.Identifier,\n  body:\n    | t.EnumBooleanBody\n    | t.EnumNumberBody\n    | t.EnumStringBody\n    | t.EnumSymbolBody,\n): t.EnumDeclaration {\n  return validateNode<t.EnumDeclaration>({\n    type: \"EnumDeclaration\",\n    id,\n    body,\n  });\n}\nexport function enumBooleanBody(\n  members: Array<t.EnumBooleanMember>,\n): t.EnumBooleanBody {\n  return validateNode<t.EnumBooleanBody>({\n    type: \"EnumBooleanBody\",\n    members,\n    explicitType: null,\n    hasUnknownMembers: null,\n  });\n}\nexport function enumNumberBody(\n  members: Array<t.EnumNumberMember>,\n): t.EnumNumberBody {\n  return validateNode<t.EnumNumberBody>({\n    type: \"EnumNumberBody\",\n    members,\n    explicitType: null,\n    hasUnknownMembers: null,\n  });\n}\nexport function enumStringBody(\n  members: Array<t.EnumStringMember | t.EnumDefaultedMember>,\n): t.EnumStringBody {\n  return validateNode<t.EnumStringBody>({\n    type: \"EnumStringBody\",\n    members,\n    explicitType: null,\n    hasUnknownMembers: null,\n  });\n}\nexport function enumSymbolBody(\n  members: Array<t.EnumDefaultedMember>,\n): t.EnumSymbolBody {\n  return validateNode<t.EnumSymbolBody>({\n    type: \"EnumSymbolBody\",\n    members,\n    hasUnknownMembers: null,\n  });\n}\nexport function enumBooleanMember(id: t.Identifier): t.EnumBooleanMember {\n  return validateNode<t.EnumBooleanMember>({\n    type: \"EnumBooleanMember\",\n    id,\n    init: null,\n  });\n}\nexport function enumNumberMember(\n  id: t.Identifier,\n  init: t.NumericLiteral,\n): t.EnumNumberMember {\n  return validateNode<t.EnumNumberMember>({\n    type: \"EnumNumberMember\",\n    id,\n    init,\n  });\n}\nexport function enumStringMember(\n  id: t.Identifier,\n  init: t.StringLiteral,\n): t.EnumStringMember {\n  return validateNode<t.EnumStringMember>({\n    type: \"EnumStringMember\",\n    id,\n    init,\n  });\n}\nexport function enumDefaultedMember(id: t.Identifier): t.EnumDefaultedMember {\n  return validateNode<t.EnumDefaultedMember>({\n    type: \"EnumDefaultedMember\",\n    id,\n  });\n}\nexport function indexedAccessType(\n  objectType: t.FlowType,\n  indexType: t.FlowType,\n): t.IndexedAccessType {\n  return validateNode<t.IndexedAccessType>({\n    type: \"IndexedAccessType\",\n    objectType,\n    indexType,\n  });\n}\nexport function optionalIndexedAccessType(\n  objectType: t.FlowType,\n  indexType: t.FlowType,\n): t.OptionalIndexedAccessType {\n  return validateNode<t.OptionalIndexedAccessType>({\n    type: \"OptionalIndexedAccessType\",\n    objectType,\n    indexType,\n    optional: null,\n  });\n}\nexport function jsxAttribute(\n  name: t.JSXIdentifier | t.JSXNamespacedName,\n  value:\n    | t.JSXElement\n    | t.JSXFragment\n    | t.StringLiteral\n    | t.JSXExpressionContainer\n    | null = null,\n): t.JSXAttribute {\n  return validateNode<t.JSXAttribute>({\n    type: \"JSXAttribute\",\n    name,\n    value,\n  });\n}\nexport { jsxAttribute as jSXAttribute };\nexport function jsxClosingElement(\n  name: t.JSXIdentifier | t.JSXMemberExpression | t.JSXNamespacedName,\n): t.JSXClosingElement {\n  return validateNode<t.JSXClosingElement>({\n    type: \"JSXClosingElement\",\n    name,\n  });\n}\nexport { jsxClosingElement as jSXClosingElement };\nexport function jsxElement(\n  openingElement: t.JSXOpeningElement,\n  closingElement: t.JSXClosingElement | null | undefined = null,\n  children: Array<\n    | t.JSXText\n    | t.JSXExpressionContainer\n    | t.JSXSpreadChild\n    | t.JSXElement\n    | t.JSXFragment\n  >,\n  selfClosing: boolean | null = null,\n): t.JSXElement {\n  return validateNode<t.JSXElement>({\n    type: \"JSXElement\",\n    openingElement,\n    closingElement,\n    children,\n    selfClosing,\n  });\n}\nexport { jsxElement as jSXElement };\nexport function jsxEmptyExpression(): t.JSXEmptyExpression {\n  return {\n    type: \"JSXEmptyExpression\",\n  };\n}\nexport { jsxEmptyExpression as jSXEmptyExpression };\nexport function jsxExpressionContainer(\n  expression: t.Expression | t.JSXEmptyExpression,\n): t.JSXExpressionContainer {\n  return validateNode<t.JSXExpressionContainer>({\n    type: \"JSXExpressionContainer\",\n    expression,\n  });\n}\nexport { jsxExpressionContainer as jSXExpressionContainer };\nexport function jsxSpreadChild(expression: t.Expression): t.JSXSpreadChild {\n  return validateNode<t.JSXSpreadChild>({\n    type: \"JSXSpreadChild\",\n    expression,\n  });\n}\nexport { jsxSpreadChild as jSXSpreadChild };\nexport function jsxIdentifier(name: string): t.JSXIdentifier {\n  return validateNode<t.JSXIdentifier>({\n    type: \"JSXIdentifier\",\n    name,\n  });\n}\nexport { jsxIdentifier as jSXIdentifier };\nexport function jsxMemberExpression(\n  object: t.JSXMemberExpression | t.JSXIdentifier,\n  property: t.JSXIdentifier,\n): t.JSXMemberExpression {\n  return validateNode<t.JSXMemberExpression>({\n    type: \"JSXMemberExpression\",\n    object,\n    property,\n  });\n}\nexport { jsxMemberExpression as jSXMemberExpression };\nexport function jsxNamespacedName(\n  namespace: t.JSXIdentifier,\n  name: t.JSXIdentifier,\n): t.JSXNamespacedName {\n  return validateNode<t.JSXNamespacedName>({\n    type: \"JSXNamespacedName\",\n    namespace,\n    name,\n  });\n}\nexport { jsxNamespacedName as jSXNamespacedName };\nexport function jsxOpeningElement(\n  name: t.JSXIdentifier | t.JSXMemberExpression | t.JSXNamespacedName,\n  attributes: Array<t.JSXAttribute | t.JSXSpreadAttribute>,\n  selfClosing: boolean = false,\n): t.JSXOpeningElement {\n  return validateNode<t.JSXOpeningElement>({\n    type: \"JSXOpeningElement\",\n    name,\n    attributes,\n    selfClosing,\n  });\n}\nexport { jsxOpeningElement as jSXOpeningElement };\nexport function jsxSpreadAttribute(\n  argument: t.Expression,\n): t.JSXSpreadAttribute {\n  return validateNode<t.JSXSpreadAttribute>({\n    type: \"JSXSpreadAttribute\",\n    argument,\n  });\n}\nexport { jsxSpreadAttribute as jSXSpreadAttribute };\nexport function jsxText(value: string): t.JSXText {\n  return validateNode<t.JSXText>({\n    type: \"JSXText\",\n    value,\n  });\n}\nexport { jsxText as jSXText };\nexport function jsxFragment(\n  openingFragment: t.JSXOpeningFragment,\n  closingFragment: t.JSXClosingFragment,\n  children: Array<\n    | t.JSXText\n    | t.JSXExpressionContainer\n    | t.JSXSpreadChild\n    | t.JSXElement\n    | t.JSXFragment\n  >,\n): t.JSXFragment {\n  return validateNode<t.JSXFragment>({\n    type: \"JSXFragment\",\n    openingFragment,\n    closingFragment,\n    children,\n  });\n}\nexport { jsxFragment as jSXFragment };\nexport function jsxOpeningFragment(): t.JSXOpeningFragment {\n  return {\n    type: \"JSXOpeningFragment\",\n  };\n}\nexport { jsxOpeningFragment as jSXOpeningFragment };\nexport function jsxClosingFragment(): t.JSXClosingFragment {\n  return {\n    type: \"JSXClosingFragment\",\n  };\n}\nexport { jsxClosingFragment as jSXClosingFragment };\nexport function noop(): t.Noop {\n  return {\n    type: \"Noop\",\n  };\n}\nexport function placeholder(\n  expectedNode:\n    | \"Identifier\"\n    | \"StringLiteral\"\n    | \"Expression\"\n    | \"Statement\"\n    | \"Declaration\"\n    | \"BlockStatement\"\n    | \"ClassBody\"\n    | \"Pattern\",\n  name: t.Identifier,\n): t.Placeholder {\n  return validateNode<t.Placeholder>({\n    type: \"Placeholder\",\n    expectedNode,\n    name,\n  });\n}\nexport function v8IntrinsicIdentifier(name: string): t.V8IntrinsicIdentifier {\n  return validateNode<t.V8IntrinsicIdentifier>({\n    type: \"V8IntrinsicIdentifier\",\n    name,\n  });\n}\nexport function argumentPlaceholder(): t.ArgumentPlaceholder {\n  return {\n    type: \"ArgumentPlaceholder\",\n  };\n}\nexport function bindExpression(\n  object: t.Expression,\n  callee: t.Expression,\n): t.BindExpression {\n  return validateNode<t.BindExpression>({\n    type: \"BindExpression\",\n    object,\n    callee,\n  });\n}\nexport function importAttribute(\n  key: t.Identifier | t.StringLiteral,\n  value: t.StringLiteral,\n): t.ImportAttribute {\n  return validateNode<t.ImportAttribute>({\n    type: \"ImportAttribute\",\n    key,\n    value,\n  });\n}\nexport function decorator(expression: t.Expression): t.Decorator {\n  return validateNode<t.Decorator>({\n    type: \"Decorator\",\n    expression,\n  });\n}\nexport function doExpression(\n  body: t.BlockStatement,\n  async: boolean = false,\n): t.DoExpression {\n  return validateNode<t.DoExpression>({\n    type: \"DoExpression\",\n    body,\n    async,\n  });\n}\nexport function exportDefaultSpecifier(\n  exported: t.Identifier,\n): t.ExportDefaultSpecifier {\n  return validateNode<t.ExportDefaultSpecifier>({\n    type: \"ExportDefaultSpecifier\",\n    exported,\n  });\n}\nexport function recordExpression(\n  properties: Array<t.ObjectProperty | t.SpreadElement>,\n): t.RecordExpression {\n  return validateNode<t.RecordExpression>({\n    type: \"RecordExpression\",\n    properties,\n  });\n}\nexport function tupleExpression(\n  elements: Array<t.Expression | t.SpreadElement> = [],\n): t.TupleExpression {\n  return validateNode<t.TupleExpression>({\n    type: \"TupleExpression\",\n    elements,\n  });\n}\nexport function decimalLiteral(value: string): t.DecimalLiteral {\n  return validateNode<t.DecimalLiteral>({\n    type: \"DecimalLiteral\",\n    value,\n  });\n}\nexport function moduleExpression(body: t.Program): t.ModuleExpression {\n  return validateNode<t.ModuleExpression>({\n    type: \"ModuleExpression\",\n    body,\n  });\n}\nexport function topicReference(): t.TopicReference {\n  return {\n    type: \"TopicReference\",\n  };\n}\nexport function pipelineTopicExpression(\n  expression: t.Expression,\n): t.PipelineTopicExpression {\n  return validateNode<t.PipelineTopicExpression>({\n    type: \"PipelineTopicExpression\",\n    expression,\n  });\n}\nexport function pipelineBareFunction(\n  callee: t.Expression,\n): t.PipelineBareFunction {\n  return validateNode<t.PipelineBareFunction>({\n    type: \"PipelineBareFunction\",\n    callee,\n  });\n}\nexport function pipelinePrimaryTopicReference(): t.PipelinePrimaryTopicReference {\n  return {\n    type: \"PipelinePrimaryTopicReference\",\n  };\n}\nexport function tsParameterProperty(\n  parameter: t.Identifier | t.AssignmentPattern,\n): t.TSParameterProperty {\n  return validateNode<t.TSParameterProperty>({\n    type: \"TSParameterProperty\",\n    parameter,\n  });\n}\nexport { tsParameterProperty as tSParameterProperty };\nexport function tsDeclareFunction(\n  id: t.Identifier | null | undefined = null,\n  typeParameters:\n    | t.TSTypeParameterDeclaration\n    | t.Noop\n    | null\n    | undefined = null,\n  params: Array<t.Identifier | t.Pattern | t.RestElement>,\n  returnType: t.TSTypeAnnotation | t.Noop | null = null,\n): t.TSDeclareFunction {\n  return validateNode<t.TSDeclareFunction>({\n    type: \"TSDeclareFunction\",\n    id,\n    typeParameters,\n    params,\n    returnType,\n  });\n}\nexport { tsDeclareFunction as tSDeclareFunction };\nexport function tsDeclareMethod(\n  decorators: Array<t.Decorator> | null | undefined = null,\n  key:\n    | t.Identifier\n    | t.StringLiteral\n    | t.NumericLiteral\n    | t.BigIntLiteral\n    | t.Expression,\n  typeParameters:\n    | t.TSTypeParameterDeclaration\n    | t.Noop\n    | null\n    | undefined = null,\n  params: Array<\n    t.Identifier | t.Pattern | t.RestElement | t.TSParameterProperty\n  >,\n  returnType: t.TSTypeAnnotation | t.Noop | null = null,\n): t.TSDeclareMethod {\n  return validateNode<t.TSDeclareMethod>({\n    type: \"TSDeclareMethod\",\n    decorators,\n    key,\n    typeParameters,\n    params,\n    returnType,\n  });\n}\nexport { tsDeclareMethod as tSDeclareMethod };\nexport function tsQualifiedName(\n  left: t.TSEntityName,\n  right: t.Identifier,\n): t.TSQualifiedName {\n  return validateNode<t.TSQualifiedName>({\n    type: \"TSQualifiedName\",\n    left,\n    right,\n  });\n}\nexport { tsQualifiedName as tSQualifiedName };\nexport function tsCallSignatureDeclaration(\n  typeParameters: t.TSTypeParameterDeclaration | null | undefined = null,\n  parameters: Array<t.Identifier | t.RestElement>,\n  typeAnnotation: t.TSTypeAnnotation | null = null,\n): t.TSCallSignatureDeclaration {\n  return validateNode<t.TSCallSignatureDeclaration>({\n    type: \"TSCallSignatureDeclaration\",\n    typeParameters,\n    parameters,\n    typeAnnotation,\n  });\n}\nexport { tsCallSignatureDeclaration as tSCallSignatureDeclaration };\nexport function tsConstructSignatureDeclaration(\n  typeParameters: t.TSTypeParameterDeclaration | null | undefined = null,\n  parameters: Array<t.Identifier | t.RestElement>,\n  typeAnnotation: t.TSTypeAnnotation | null = null,\n): t.TSConstructSignatureDeclaration {\n  return validateNode<t.TSConstructSignatureDeclaration>({\n    type: \"TSConstructSignatureDeclaration\",\n    typeParameters,\n    parameters,\n    typeAnnotation,\n  });\n}\nexport { tsConstructSignatureDeclaration as tSConstructSignatureDeclaration };\nexport function tsPropertySignature(\n  key: t.Expression,\n  typeAnnotation: t.TSTypeAnnotation | null = null,\n  initializer: t.Expression | null = null,\n): t.TSPropertySignature {\n  return validateNode<t.TSPropertySignature>({\n    type: \"TSPropertySignature\",\n    key,\n    typeAnnotation,\n    initializer,\n    kind: null,\n  });\n}\nexport { tsPropertySignature as tSPropertySignature };\nexport function tsMethodSignature(\n  key: t.Expression,\n  typeParameters: t.TSTypeParameterDeclaration | null | undefined = null,\n  parameters: Array<t.Identifier | t.RestElement>,\n  typeAnnotation: t.TSTypeAnnotation | null = null,\n): t.TSMethodSignature {\n  return validateNode<t.TSMethodSignature>({\n    type: \"TSMethodSignature\",\n    key,\n    typeParameters,\n    parameters,\n    typeAnnotation,\n    kind: null,\n  });\n}\nexport { tsMethodSignature as tSMethodSignature };\nexport function tsIndexSignature(\n  parameters: Array<t.Identifier>,\n  typeAnnotation: t.TSTypeAnnotation | null = null,\n): t.TSIndexSignature {\n  return validateNode<t.TSIndexSignature>({\n    type: \"TSIndexSignature\",\n    parameters,\n    typeAnnotation,\n  });\n}\nexport { tsIndexSignature as tSIndexSignature };\nexport function tsAnyKeyword(): t.TSAnyKeyword {\n  return {\n    type: \"TSAnyKeyword\",\n  };\n}\nexport { tsAnyKeyword as tSAnyKeyword };\nexport function tsBooleanKeyword(): t.TSBooleanKeyword {\n  return {\n    type: \"TSBooleanKeyword\",\n  };\n}\nexport { tsBooleanKeyword as tSBooleanKeyword };\nexport function tsBigIntKeyword(): t.TSBigIntKeyword {\n  return {\n    type: \"TSBigIntKeyword\",\n  };\n}\nexport { tsBigIntKeyword as tSBigIntKeyword };\nexport function tsIntrinsicKeyword(): t.TSIntrinsicKeyword {\n  return {\n    type: \"TSIntrinsicKeyword\",\n  };\n}\nexport { tsIntrinsicKeyword as tSIntrinsicKeyword };\nexport function tsNeverKeyword(): t.TSNeverKeyword {\n  return {\n    type: \"TSNeverKeyword\",\n  };\n}\nexport { tsNeverKeyword as tSNeverKeyword };\nexport function tsNullKeyword(): t.TSNullKeyword {\n  return {\n    type: \"TSNullKeyword\",\n  };\n}\nexport { tsNullKeyword as tSNullKeyword };\nexport function tsNumberKeyword(): t.TSNumberKeyword {\n  return {\n    type: \"TSNumberKeyword\",\n  };\n}\nexport { tsNumberKeyword as tSNumberKeyword };\nexport function tsObjectKeyword(): t.TSObjectKeyword {\n  return {\n    type: \"TSObjectKeyword\",\n  };\n}\nexport { tsObjectKeyword as tSObjectKeyword };\nexport function tsStringKeyword(): t.TSStringKeyword {\n  return {\n    type: \"TSStringKeyword\",\n  };\n}\nexport { tsStringKeyword as tSStringKeyword };\nexport function tsSymbolKeyword(): t.TSSymbolKeyword {\n  return {\n    type: \"TSSymbolKeyword\",\n  };\n}\nexport { tsSymbolKeyword as tSSymbolKeyword };\nexport function tsUndefinedKeyword(): t.TSUndefinedKeyword {\n  return {\n    type: \"TSUndefinedKeyword\",\n  };\n}\nexport { tsUndefinedKeyword as tSUndefinedKeyword };\nexport function tsUnknownKeyword(): t.TSUnknownKeyword {\n  return {\n    type: \"TSUnknownKeyword\",\n  };\n}\nexport { tsUnknownKeyword as tSUnknownKeyword };\nexport function tsVoidKeyword(): t.TSVoidKeyword {\n  return {\n    type: \"TSVoidKeyword\",\n  };\n}\nexport { tsVoidKeyword as tSVoidKeyword };\nexport function tsThisType(): t.TSThisType {\n  return {\n    type: \"TSThisType\",\n  };\n}\nexport { tsThisType as tSThisType };\nexport function tsFunctionType(\n  typeParameters: t.TSTypeParameterDeclaration | null | undefined = null,\n  parameters: Array<t.Identifier | t.RestElement>,\n  typeAnnotation: t.TSTypeAnnotation | null = null,\n): t.TSFunctionType {\n  return validateNode<t.TSFunctionType>({\n    type: \"TSFunctionType\",\n    typeParameters,\n    parameters,\n    typeAnnotation,\n  });\n}\nexport { tsFunctionType as tSFunctionType };\nexport function tsConstructorType(\n  typeParameters: t.TSTypeParameterDeclaration | null | undefined = null,\n  parameters: Array<t.Identifier | t.RestElement>,\n  typeAnnotation: t.TSTypeAnnotation | null = null,\n): t.TSConstructorType {\n  return validateNode<t.TSConstructorType>({\n    type: \"TSConstructorType\",\n    typeParameters,\n    parameters,\n    typeAnnotation,\n  });\n}\nexport { tsConstructorType as tSConstructorType };\nexport function tsTypeReference(\n  typeName: t.TSEntityName,\n  typeParameters: t.TSTypeParameterInstantiation | null = null,\n): t.TSTypeReference {\n  return validateNode<t.TSTypeReference>({\n    type: \"TSTypeReference\",\n    typeName,\n    typeParameters,\n  });\n}\nexport { tsTypeReference as tSTypeReference };\nexport function tsTypePredicate(\n  parameterName: t.Identifier | t.TSThisType,\n  typeAnnotation: t.TSTypeAnnotation | null = null,\n  asserts: boolean | null = null,\n): t.TSTypePredicate {\n  return validateNode<t.TSTypePredicate>({\n    type: \"TSTypePredicate\",\n    parameterName,\n    typeAnnotation,\n    asserts,\n  });\n}\nexport { tsTypePredicate as tSTypePredicate };\nexport function tsTypeQuery(\n  exprName: t.TSEntityName | t.TSImportType,\n  typeParameters: t.TSTypeParameterInstantiation | null = null,\n): t.TSTypeQuery {\n  return validateNode<t.TSTypeQuery>({\n    type: \"TSTypeQuery\",\n    exprName,\n    typeParameters,\n  });\n}\nexport { tsTypeQuery as tSTypeQuery };\nexport function tsTypeLiteral(\n  members: Array<t.TSTypeElement>,\n): t.TSTypeLiteral {\n  return validateNode<t.TSTypeLiteral>({\n    type: \"TSTypeLiteral\",\n    members,\n  });\n}\nexport { tsTypeLiteral as tSTypeLiteral };\nexport function tsArrayType(elementType: t.TSType): t.TSArrayType {\n  return validateNode<t.TSArrayType>({\n    type: \"TSArrayType\",\n    elementType,\n  });\n}\nexport { tsArrayType as tSArrayType };\nexport function tsTupleType(\n  elementTypes: Array<t.TSType | t.TSNamedTupleMember>,\n): t.TSTupleType {\n  return validateNode<t.TSTupleType>({\n    type: \"TSTupleType\",\n    elementTypes,\n  });\n}\nexport { tsTupleType as tSTupleType };\nexport function tsOptionalType(typeAnnotation: t.TSType): t.TSOptionalType {\n  return validateNode<t.TSOptionalType>({\n    type: \"TSOptionalType\",\n    typeAnnotation,\n  });\n}\nexport { tsOptionalType as tSOptionalType };\nexport function tsRestType(typeAnnotation: t.TSType): t.TSRestType {\n  return validateNode<t.TSRestType>({\n    type: \"TSRestType\",\n    typeAnnotation,\n  });\n}\nexport { tsRestType as tSRestType };\nexport function tsNamedTupleMember(\n  label: t.Identifier,\n  elementType: t.TSType,\n  optional: boolean = false,\n): t.TSNamedTupleMember {\n  return validateNode<t.TSNamedTupleMember>({\n    type: \"TSNamedTupleMember\",\n    label,\n    elementType,\n    optional,\n  });\n}\nexport { tsNamedTupleMember as tSNamedTupleMember };\nexport function tsUnionType(types: Array<t.TSType>): t.TSUnionType {\n  return validateNode<t.TSUnionType>({\n    type: \"TSUnionType\",\n    types,\n  });\n}\nexport { tsUnionType as tSUnionType };\nexport function tsIntersectionType(\n  types: Array<t.TSType>,\n): t.TSIntersectionType {\n  return validateNode<t.TSIntersectionType>({\n    type: \"TSIntersectionType\",\n    types,\n  });\n}\nexport { tsIntersectionType as tSIntersectionType };\nexport function tsConditionalType(\n  checkType: t.TSType,\n  extendsType: t.TSType,\n  trueType: t.TSType,\n  falseType: t.TSType,\n): t.TSConditionalType {\n  return validateNode<t.TSConditionalType>({\n    type: \"TSConditionalType\",\n    checkType,\n    extendsType,\n    trueType,\n    falseType,\n  });\n}\nexport { tsConditionalType as tSConditionalType };\nexport function tsInferType(typeParameter: t.TSTypeParameter): t.TSInferType {\n  return validateNode<t.TSInferType>({\n    type: \"TSInferType\",\n    typeParameter,\n  });\n}\nexport { tsInferType as tSInferType };\nexport function tsParenthesizedType(\n  typeAnnotation: t.TSType,\n): t.TSParenthesizedType {\n  return validateNode<t.TSParenthesizedType>({\n    type: \"TSParenthesizedType\",\n    typeAnnotation,\n  });\n}\nexport { tsParenthesizedType as tSParenthesizedType };\nexport function tsTypeOperator(typeAnnotation: t.TSType): t.TSTypeOperator {\n  return validateNode<t.TSTypeOperator>({\n    type: \"TSTypeOperator\",\n    typeAnnotation,\n    operator: null,\n  });\n}\nexport { tsTypeOperator as tSTypeOperator };\nexport function tsIndexedAccessType(\n  objectType: t.TSType,\n  indexType: t.TSType,\n): t.TSIndexedAccessType {\n  return validateNode<t.TSIndexedAccessType>({\n    type: \"TSIndexedAccessType\",\n    objectType,\n    indexType,\n  });\n}\nexport { tsIndexedAccessType as tSIndexedAccessType };\nexport function tsMappedType(\n  typeParameter: t.TSTypeParameter,\n  typeAnnotation: t.TSType | null = null,\n  nameType: t.TSType | null = null,\n): t.TSMappedType {\n  return validateNode<t.TSMappedType>({\n    type: \"TSMappedType\",\n    typeParameter,\n    typeAnnotation,\n    nameType,\n  });\n}\nexport { tsMappedType as tSMappedType };\nexport function tsLiteralType(\n  literal:\n    | t.NumericLiteral\n    | t.StringLiteral\n    | t.BooleanLiteral\n    | t.BigIntLiteral\n    | t.TemplateLiteral\n    | t.UnaryExpression,\n): t.TSLiteralType {\n  return validateNode<t.TSLiteralType>({\n    type: \"TSLiteralType\",\n    literal,\n  });\n}\nexport { tsLiteralType as tSLiteralType };\nexport function tsExpressionWithTypeArguments(\n  expression: t.TSEntityName,\n  typeParameters: t.TSTypeParameterInstantiation | null = null,\n): t.TSExpressionWithTypeArguments {\n  return validateNode<t.TSExpressionWithTypeArguments>({\n    type: \"TSExpressionWithTypeArguments\",\n    expression,\n    typeParameters,\n  });\n}\nexport { tsExpressionWithTypeArguments as tSExpressionWithTypeArguments };\nexport function tsInterfaceDeclaration(\n  id: t.Identifier,\n  typeParameters: t.TSTypeParameterDeclaration | null | undefined = null,\n  _extends: Array<t.TSExpressionWithTypeArguments> | null | undefined = null,\n  body: t.TSInterfaceBody,\n): t.TSInterfaceDeclaration {\n  return validateNode<t.TSInterfaceDeclaration>({\n    type: \"TSInterfaceDeclaration\",\n    id,\n    typeParameters,\n    extends: _extends,\n    body,\n  });\n}\nexport { tsInterfaceDeclaration as tSInterfaceDeclaration };\nexport function tsInterfaceBody(\n  body: Array<t.TSTypeElement>,\n): t.TSInterfaceBody {\n  return validateNode<t.TSInterfaceBody>({\n    type: \"TSInterfaceBody\",\n    body,\n  });\n}\nexport { tsInterfaceBody as tSInterfaceBody };\nexport function tsTypeAliasDeclaration(\n  id: t.Identifier,\n  typeParameters: t.TSTypeParameterDeclaration | null | undefined = null,\n  typeAnnotation: t.TSType,\n): t.TSTypeAliasDeclaration {\n  return validateNode<t.TSTypeAliasDeclaration>({\n    type: \"TSTypeAliasDeclaration\",\n    id,\n    typeParameters,\n    typeAnnotation,\n  });\n}\nexport { tsTypeAliasDeclaration as tSTypeAliasDeclaration };\nexport function tsInstantiationExpression(\n  expression: t.Expression,\n  typeParameters: t.TSTypeParameterInstantiation | null = null,\n): t.TSInstantiationExpression {\n  return validateNode<t.TSInstantiationExpression>({\n    type: \"TSInstantiationExpression\",\n    expression,\n    typeParameters,\n  });\n}\nexport { tsInstantiationExpression as tSInstantiationExpression };\nexport function tsAsExpression(\n  expression: t.Expression,\n  typeAnnotation: t.TSType,\n): t.TSAsExpression {\n  return validateNode<t.TSAsExpression>({\n    type: \"TSAsExpression\",\n    expression,\n    typeAnnotation,\n  });\n}\nexport { tsAsExpression as tSAsExpression };\nexport function tsSatisfiesExpression(\n  expression: t.Expression,\n  typeAnnotation: t.TSType,\n): t.TSSatisfiesExpression {\n  return validateNode<t.TSSatisfiesExpression>({\n    type: \"TSSatisfiesExpression\",\n    expression,\n    typeAnnotation,\n  });\n}\nexport { tsSatisfiesExpression as tSSatisfiesExpression };\nexport function tsTypeAssertion(\n  typeAnnotation: t.TSType,\n  expression: t.Expression,\n): t.TSTypeAssertion {\n  return validateNode<t.TSTypeAssertion>({\n    type: \"TSTypeAssertion\",\n    typeAnnotation,\n    expression,\n  });\n}\nexport { tsTypeAssertion as tSTypeAssertion };\nexport function tsEnumDeclaration(\n  id: t.Identifier,\n  members: Array<t.TSEnumMember>,\n): t.TSEnumDeclaration {\n  return validateNode<t.TSEnumDeclaration>({\n    type: \"TSEnumDeclaration\",\n    id,\n    members,\n  });\n}\nexport { tsEnumDeclaration as tSEnumDeclaration };\nexport function tsEnumMember(\n  id: t.Identifier | t.StringLiteral,\n  initializer: t.Expression | null = null,\n): t.TSEnumMember {\n  return validateNode<t.TSEnumMember>({\n    type: \"TSEnumMember\",\n    id,\n    initializer,\n  });\n}\nexport { tsEnumMember as tSEnumMember };\nexport function tsModuleDeclaration(\n  id: t.Identifier | t.StringLiteral,\n  body: t.TSModuleBlock | t.TSModuleDeclaration,\n): t.TSModuleDeclaration {\n  return validateNode<t.TSModuleDeclaration>({\n    type: \"TSModuleDeclaration\",\n    id,\n    body,\n  });\n}\nexport { tsModuleDeclaration as tSModuleDeclaration };\nexport function tsModuleBlock(body: Array<t.Statement>): t.TSModuleBlock {\n  return validateNode<t.TSModuleBlock>({\n    type: \"TSModuleBlock\",\n    body,\n  });\n}\nexport { tsModuleBlock as tSModuleBlock };\nexport function tsImportType(\n  argument: t.StringLiteral,\n  qualifier: t.TSEntityName | null = null,\n  typeParameters: t.TSTypeParameterInstantiation | null = null,\n): t.TSImportType {\n  return validateNode<t.TSImportType>({\n    type: \"TSImportType\",\n    argument,\n    qualifier,\n    typeParameters,\n  });\n}\nexport { tsImportType as tSImportType };\nexport function tsImportEqualsDeclaration(\n  id: t.Identifier,\n  moduleReference: t.TSEntityName | t.TSExternalModuleReference,\n): t.TSImportEqualsDeclaration {\n  return validateNode<t.TSImportEqualsDeclaration>({\n    type: \"TSImportEqualsDeclaration\",\n    id,\n    moduleReference,\n    isExport: null,\n  });\n}\nexport { tsImportEqualsDeclaration as tSImportEqualsDeclaration };\nexport function tsExternalModuleReference(\n  expression: t.StringLiteral,\n): t.TSExternalModuleReference {\n  return validateNode<t.TSExternalModuleReference>({\n    type: \"TSExternalModuleReference\",\n    expression,\n  });\n}\nexport { tsExternalModuleReference as tSExternalModuleReference };\nexport function tsNonNullExpression(\n  expression: t.Expression,\n): t.TSNonNullExpression {\n  return validateNode<t.TSNonNullExpression>({\n    type: \"TSNonNullExpression\",\n    expression,\n  });\n}\nexport { tsNonNullExpression as tSNonNullExpression };\nexport function tsExportAssignment(\n  expression: t.Expression,\n): t.TSExportAssignment {\n  return validateNode<t.TSExportAssignment>({\n    type: \"TSExportAssignment\",\n    expression,\n  });\n}\nexport { tsExportAssignment as tSExportAssignment };\nexport function tsNamespaceExportDeclaration(\n  id: t.Identifier,\n): t.TSNamespaceExportDeclaration {\n  return validateNode<t.TSNamespaceExportDeclaration>({\n    type: \"TSNamespaceExportDeclaration\",\n    id,\n  });\n}\nexport { tsNamespaceExportDeclaration as tSNamespaceExportDeclaration };\nexport function tsTypeAnnotation(typeAnnotation: t.TSType): t.TSTypeAnnotation {\n  return validateNode<t.TSTypeAnnotation>({\n    type: \"TSTypeAnnotation\",\n    typeAnnotation,\n  });\n}\nexport { tsTypeAnnotation as tSTypeAnnotation };\nexport function tsTypeParameterInstantiation(\n  params: Array<t.TSType>,\n): t.TSTypeParameterInstantiation {\n  return validateNode<t.TSTypeParameterInstantiation>({\n    type: \"TSTypeParameterInstantiation\",\n    params,\n  });\n}\nexport { tsTypeParameterInstantiation as tSTypeParameterInstantiation };\nexport function tsTypeParameterDeclaration(\n  params: Array<t.TSTypeParameter>,\n): t.TSTypeParameterDeclaration {\n  return validateNode<t.TSTypeParameterDeclaration>({\n    type: \"TSTypeParameterDeclaration\",\n    params,\n  });\n}\nexport { tsTypeParameterDeclaration as tSTypeParameterDeclaration };\nexport function tsTypeParameter(\n  constraint: t.TSType | null | undefined = null,\n  _default: t.TSType | null | undefined = null,\n  name: string,\n): t.TSTypeParameter {\n  return validateNode<t.TSTypeParameter>({\n    type: \"TSTypeParameter\",\n    constraint,\n    default: _default,\n    name,\n  });\n}\nexport { tsTypeParameter as tSTypeParameter };\n/** @deprecated */\nfunction NumberLiteral(value: number) {\n  deprecationWarning(\"NumberLiteral\", \"NumericLiteral\", \"The node type \");\n  return numericLiteral(value);\n}\nexport { NumberLiteral as numberLiteral };\n/** @deprecated */\nfunction RegexLiteral(pattern: string, flags: string = \"\") {\n  deprecationWarning(\"RegexLiteral\", \"RegExpLiteral\", \"The node type \");\n  return regExpLiteral(pattern, flags);\n}\nexport { RegexLiteral as regexLiteral };\n/** @deprecated */\nfunction RestProperty(argument: t.LVal) {\n  deprecationWarning(\"RestProperty\", \"RestElement\", \"The node type \");\n  return restElement(argument);\n}\nexport { RestProperty as restProperty };\n/** @deprecated */\nfunction SpreadProperty(argument: t.Expression) {\n  deprecationWarning(\"SpreadProperty\", \"SpreadElement\", \"The node type \");\n  return spreadElement(argument);\n}\nexport { SpreadProperty as spreadProperty };\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}