{"ast":null,"code":"import _extends from '@babel/runtime/helpers/extends';\nimport _inheritsLoose from '@babel/runtime/helpers/inheritsLoose';\nimport React from 'react';\nimport PropTypes from 'prop-types';\nvar _jsxFileName = \"/Users/krise/github/react-slider/src/components/ReactSlider/ReactSlider.jsx\";\n/**\n * To prevent text selection while dragging.\n * http://stackoverflow.com/questions/5429827/how-can-i-prevent-text-element-selection-with-cursor-drag\n */\n\nfunction pauseEvent(e) {\n  if (e && e.stopPropagation) {\n    e.stopPropagation();\n  }\n  if (e && e.preventDefault) {\n    e.preventDefault();\n  }\n  return false;\n}\nfunction stopPropagation(e) {\n  if (e.stopPropagation) {\n    e.stopPropagation();\n  }\n}\nfunction sanitizeInValue(x) {\n  if (x == null) {\n    return [];\n  }\n  return Array.isArray(x) ? x.slice() : [x];\n}\nfunction prepareOutValue(x) {\n  return x !== null && x.length === 1 ? x[0] : x.slice();\n}\nfunction trimSucceeding(length, nextValue, minDistance, max) {\n  for (let i = 0; i < length; i += 1) {\n    const padding = max - i * minDistance;\n    if (nextValue[length - 1 - i] > padding) {\n      // eslint-disable-next-line no-param-reassign\n      nextValue[length - 1 - i] = padding;\n    }\n  }\n}\nfunction trimPreceding(length, nextValue, minDistance, min) {\n  for (let i = 0; i < length; i += 1) {\n    const padding = min + i * minDistance;\n    if (nextValue[i] < padding) {\n      // eslint-disable-next-line no-param-reassign\n      nextValue[i] = padding;\n    }\n  }\n}\nfunction addHandlers(eventMap) {\n  Object.keys(eventMap).forEach(key => {\n    if (typeof document !== 'undefined') {\n      document.addEventListener(key, eventMap[key], false);\n    }\n  });\n}\nfunction removeHandlers(eventMap) {\n  Object.keys(eventMap).forEach(key => {\n    if (typeof document !== 'undefined') {\n      document.removeEventListener(key, eventMap[key], false);\n    }\n  });\n}\nfunction trimAlignValue(val, props) {\n  return alignValue(trimValue(val, props), props);\n}\nfunction alignValue(val, props) {\n  const valModStep = (val - props.min) % props.step;\n  let alignedValue = val - valModStep;\n  if (Math.abs(valModStep) * 2 >= props.step) {\n    alignedValue += valModStep > 0 ? props.step : -props.step;\n  }\n  return parseFloat(alignedValue.toFixed(5));\n}\nfunction trimValue(val, props) {\n  let trimmed = val;\n  if (trimmed <= props.min) {\n    trimmed = props.min;\n  }\n  if (trimmed >= props.max) {\n    trimmed = props.max;\n  }\n  return trimmed;\n}\nlet ReactSlider = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose(ReactSlider, _React$Component);\n  function ReactSlider(_props) {\n    var _this;\n    _this = _React$Component.call(this, _props) || this;\n    _this.onKeyUp = () => {\n      _this.onEnd();\n    };\n    _this.onMouseUp = () => {\n      _this.onEnd(_this.getMouseEventMap());\n    };\n    _this.onTouchEnd = () => {\n      _this.onEnd(_this.getTouchEventMap());\n    };\n    _this.onBlur = () => {\n      _this.setState({\n        index: -1\n      }, _this.onEnd(_this.getKeyDownEventMap()));\n    };\n    _this.onMouseMove = e => {\n      // Prevent controlled updates from happening while mouse is moving\n      _this.setState({\n        pending: true\n      });\n      const position = _this.getMousePosition(e);\n      const diffPosition = _this.getDiffPosition(position[0]);\n      const newValue = _this.getValueFromPosition(diffPosition);\n      _this.move(newValue);\n    };\n    _this.onTouchMove = e => {\n      if (e.touches.length > 1) {\n        return;\n      } // Prevent controlled updates from happending while touch is moving\n\n      _this.setState({\n        pending: true\n      });\n      const position = _this.getTouchPosition(e);\n      if (typeof _this.isScrolling === 'undefined') {\n        const diffMainDir = position[0] - _this.startPosition[0];\n        const diffScrollDir = position[1] - _this.startPosition[1];\n        _this.isScrolling = Math.abs(diffScrollDir) > Math.abs(diffMainDir);\n      }\n      if (_this.isScrolling) {\n        _this.setState({\n          index: -1\n        });\n        return;\n      }\n      const diffPosition = _this.getDiffPosition(position[0]);\n      const newValue = _this.getValueFromPosition(diffPosition);\n      _this.move(newValue);\n    };\n    _this.onKeyDown = e => {\n      if (e.ctrlKey || e.shiftKey || e.altKey || e.metaKey) {\n        return;\n      } // Prevent controlled updates from happening while a key is pressed\n\n      _this.setState({\n        pending: true\n      });\n      switch (e.key) {\n        case 'ArrowLeft':\n        case 'ArrowDown':\n        case 'Left':\n        case 'Down':\n          e.preventDefault();\n          _this.moveDownByStep();\n          break;\n        case 'ArrowRight':\n        case 'ArrowUp':\n        case 'Right':\n        case 'Up':\n          e.preventDefault();\n          _this.moveUpByStep();\n          break;\n        case 'Home':\n          e.preventDefault();\n          _this.move(_this.props.min);\n          break;\n        case 'End':\n          e.preventDefault();\n          _this.move(_this.props.max);\n          break;\n        case 'PageDown':\n          e.preventDefault();\n          _this.moveDownByStep(_this.props.pageFn(_this.props.step));\n          break;\n        case 'PageUp':\n          e.preventDefault();\n          _this.moveUpByStep(_this.props.pageFn(_this.props.step));\n          break;\n      }\n    };\n    _this.onSliderMouseDown = e => {\n      // do nothing if disabled or right click\n      if (_this.props.disabled || e.button === 2) {\n        return;\n      } // Prevent controlled updates from happening while mouse is moving\n\n      _this.setState({\n        pending: true\n      });\n      if (!_this.props.snapDragDisabled) {\n        const position = _this.getMousePosition(e);\n        _this.forceValueFromPosition(position[0], i => {\n          _this.start(i, position[0]);\n          addHandlers(_this.getMouseEventMap());\n        });\n      }\n      pauseEvent(e);\n    };\n    _this.onSliderClick = e => {\n      if (_this.props.disabled) {\n        return;\n      }\n      if (_this.props.onSliderClick && !_this.hasMoved) {\n        const position = _this.getMousePosition(e);\n        const valueAtPos = trimAlignValue(_this.calcValue(_this.calcOffsetFromPosition(position[0])), _this.props);\n        _this.props.onSliderClick(valueAtPos);\n      }\n    };\n    _this.createOnKeyDown = i => e => {\n      if (_this.props.disabled) {\n        return;\n      }\n      _this.start(i);\n      addHandlers(_this.getKeyDownEventMap());\n      pauseEvent(e);\n    };\n    _this.createOnMouseDown = i => e => {\n      // do nothing if disabled or right click\n      if (_this.props.disabled || e.button === 2) {\n        return;\n      } // Prevent controlled updates from happending while mouse is moving\n\n      _this.setState({\n        pending: true\n      });\n      const position = _this.getMousePosition(e);\n      _this.start(i, position[0]);\n      addHandlers(_this.getMouseEventMap());\n      pauseEvent(e);\n    };\n    _this.createOnTouchStart = i => e => {\n      if (_this.props.disabled || e.touches.length > 1) {\n        return;\n      } // Prevent controlled updates from happending while touch is moving\n\n      _this.setState({\n        pending: true\n      });\n      const position = _this.getTouchPosition(e);\n      _this.startPosition = position; // don't know yet if the user is trying to scroll\n\n      _this.isScrolling = undefined;\n      _this.start(i, position[0]);\n      addHandlers(_this.getTouchEventMap());\n      stopPropagation(e);\n    };\n    _this.handleResize = () => {\n      // setTimeout of 0 gives element enough time to have assumed its new size if\n      // it is being resized\n      const resizeTimeout = window.setTimeout(() => {\n        // drop this timeout from pendingResizeTimeouts to reduce memory usage\n        _this.pendingResizeTimeouts.shift();\n        _this.resize();\n      }, 0);\n      _this.pendingResizeTimeouts.push(resizeTimeout);\n    };\n    _this.renderThumb = (style, i) => {\n      const className = _this.props.thumbClassName + \" \" + _this.props.thumbClassName + \"-\" + i + \" \" + (_this.state.index === i ? _this.props.thumbActiveClassName : '');\n      const props = {\n        'ref': r => {\n          _this[\"thumb\" + i] = r;\n        },\n        'key': _this.props.thumbClassName + \"-\" + i,\n        className,\n        style,\n        'onMouseDown': _this.createOnMouseDown(i),\n        'onTouchStart': _this.createOnTouchStart(i),\n        'onFocus': _this.createOnKeyDown(i),\n        'tabIndex': 0,\n        'role': 'slider',\n        'aria-orientation': _this.props.orientation,\n        'aria-valuenow': _this.state.value[i],\n        'aria-valuemin': _this.props.min,\n        'aria-valuemax': _this.props.max,\n        'aria-label': Array.isArray(_this.props.ariaLabel) ? _this.props.ariaLabel[i] : _this.props.ariaLabel,\n        'aria-labelledby': Array.isArray(_this.props.ariaLabelledby) ? _this.props.ariaLabelledby[i] : _this.props.ariaLabelledby\n      };\n      const state = {\n        index: i,\n        value: prepareOutValue(_this.state.value),\n        valueNow: _this.state.value[i]\n      };\n      if (_this.props.ariaValuetext) {\n        props['aria-valuetext'] = typeof _this.props.ariaValuetext === 'string' ? _this.props.ariaValuetext : _this.props.ariaValuetext(state);\n      }\n      return _this.props.renderThumb(props, state);\n    };\n    _this.renderTrack = (i, offsetFrom, offsetTo) => {\n      const props = {\n        key: _this.props.trackClassName + \"-\" + i,\n        className: _this.props.trackClassName + \" \" + _this.props.trackClassName + \"-\" + i,\n        style: _this.buildTrackStyle(offsetFrom, _this.state.upperBound - offsetTo)\n      };\n      const state = {\n        index: i,\n        value: prepareOutValue(_this.state.value)\n      };\n      return _this.props.renderTrack(props, state);\n    };\n    let value = sanitizeInValue(_props.value);\n    if (!value.length) {\n      value = sanitizeInValue(_props.defaultValue);\n    } // array for storing resize timeouts ids\n\n    _this.pendingResizeTimeouts = [];\n    const zIndices = [];\n    for (let i = 0; i < value.length; i += 1) {\n      value[i] = trimAlignValue(value[i], _props);\n      zIndices.push(i);\n    }\n    _this.resizeObserver = null;\n    _this.resizeElementRef = /*#__PURE__*/React.createRef();\n    _this.state = {\n      index: -1,\n      upperBound: 0,\n      sliderLength: 0,\n      value,\n      zIndices\n    };\n    return _this;\n  }\n  var _proto = ReactSlider.prototype;\n  _proto.componentDidMount = function componentDidMount() {\n    if (typeof window !== 'undefined') {\n      this.resizeObserver = new ResizeObserver(this.handleResize);\n      this.resizeObserver.observe(this.resizeElementRef.current);\n      this.resize();\n    }\n  } // Keep the internal `value` consistent with an outside `value` if present.\n  // This basically allows the slider to be a controlled component.\n  ;\n\n  ReactSlider.getDerivedStateFromProps = function getDerivedStateFromProps(props, state) {\n    const value = sanitizeInValue(props.value);\n    if (!value.length) {\n      return null;\n    } // Do not allow controlled upates to happen while we have pending updates\n\n    if (state.pending) {\n      return null;\n    }\n    return {\n      value: value.map(item => trimAlignValue(item, props))\n    };\n  };\n  _proto.componentDidUpdate = function componentDidUpdate() {\n    // If an upperBound has not yet been determined (due to the component being hidden\n    // during the mount event, or during the last resize), then calculate it now\n    if (this.state.upperBound === 0) {\n      this.resize();\n    }\n  };\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    this.clearPendingResizeTimeouts();\n    if (this.resizeObserver) {\n      this.resizeObserver.disconnect();\n    }\n  };\n  _proto.onEnd = function onEnd(eventMap) {\n    if (eventMap) {\n      removeHandlers(eventMap);\n    }\n    if (this.hasMoved) {\n      this.fireChangeEvent('onAfterChange');\n    } // Allow controlled updates to continue\n\n    this.setState({\n      pending: false\n    });\n    this.hasMoved = false;\n  };\n  _proto.getValue = function getValue() {\n    return prepareOutValue(this.state.value);\n  };\n  _proto.getClosestIndex = function getClosestIndex(pixelOffset) {\n    let minDist = Number.MAX_VALUE;\n    let closestIndex = -1;\n    const {\n      value\n    } = this.state;\n    const l = value.length;\n    for (let i = 0; i < l; i += 1) {\n      const offset = this.calcOffset(value[i]);\n      const dist = Math.abs(pixelOffset - offset);\n      if (dist < minDist) {\n        minDist = dist;\n        closestIndex = i;\n      }\n    }\n    return closestIndex;\n  };\n  _proto.getMousePosition = function getMousePosition(e) {\n    return [e[\"page\" + this.axisKey()], e[\"page\" + this.orthogonalAxisKey()]];\n  };\n  _proto.getTouchPosition = function getTouchPosition(e) {\n    const touch = e.touches[0];\n    return [touch[\"page\" + this.axisKey()], touch[\"page\" + this.orthogonalAxisKey()]];\n  };\n  _proto.getKeyDownEventMap = function getKeyDownEventMap() {\n    return {\n      keydown: this.onKeyDown,\n      keyup: this.onKeyUp,\n      focusout: this.onBlur\n    };\n  };\n  _proto.getMouseEventMap = function getMouseEventMap() {\n    return {\n      mousemove: this.onMouseMove,\n      mouseup: this.onMouseUp\n    };\n  };\n  _proto.getTouchEventMap = function getTouchEventMap() {\n    return {\n      touchmove: this.onTouchMove,\n      touchend: this.onTouchEnd\n    };\n  };\n  _proto.getValueFromPosition = function getValueFromPosition(position) {\n    const diffValue = position / (this.state.sliderLength - this.state.thumbSize) * (this.props.max - this.props.min);\n    return trimAlignValue(this.state.startValue + diffValue, this.props);\n  };\n  _proto.getDiffPosition = function getDiffPosition(position) {\n    let diffPosition = position - this.state.startPosition;\n    if (this.props.invert) {\n      diffPosition *= -1;\n    }\n    return diffPosition;\n  } // create the `keydown` handler for the i-th thumb\n  ;\n\n  _proto.resize = function resize() {\n    const {\n      slider,\n      thumb0: thumb\n    } = this;\n    if (!slider || !thumb) {\n      return;\n    }\n    const sizeKey = this.sizeKey(); // For the slider size, we want to use the client width/height, excluding any borders\n\n    const sliderRect = slider.getBoundingClientRect();\n    const sliderSize = slider[sizeKey];\n    const sliderMax = sliderRect[this.posMaxKey()];\n    const sliderMin = sliderRect[this.posMinKey()]; // For the thumb size, we want to use the outer width/height, including any borders\n\n    const thumbRect = thumb.getBoundingClientRect();\n    const thumbSize = thumbRect[sizeKey.replace('client', '').toLowerCase()];\n    const upperBound = sliderSize - thumbSize;\n    const sliderLength = Math.abs(sliderMax - sliderMin);\n    if (this.state.upperBound !== upperBound || this.state.sliderLength !== sliderLength || this.state.thumbSize !== thumbSize) {\n      this.setState({\n        upperBound,\n        sliderLength,\n        thumbSize\n      });\n    }\n  } // calculates the offset of a thumb in pixels based on its value.\n  ;\n\n  _proto.calcOffset = function calcOffset(value) {\n    const range = this.props.max - this.props.min;\n    if (range === 0) {\n      return 0;\n    }\n    const ratio = (value - this.props.min) / range;\n    return ratio * this.state.upperBound;\n  } // calculates the value corresponding to a given pixel offset, i.e. the inverse of `calcOffset`.\n  ;\n\n  _proto.calcValue = function calcValue(offset) {\n    const ratio = offset / this.state.upperBound;\n    return ratio * (this.props.max - this.props.min) + this.props.min;\n  };\n  _proto.calcOffsetFromPosition = function calcOffsetFromPosition(position) {\n    const {\n      slider\n    } = this;\n    const sliderRect = slider.getBoundingClientRect();\n    const sliderMax = sliderRect[this.posMaxKey()];\n    const sliderMin = sliderRect[this.posMinKey()]; // The `position` value passed in is the mouse position based on the window height.\n    // The slider bounding rect is based on the viewport, so we must add the window scroll\n    // offset to normalize the values.\n\n    const windowOffset = window[\"page\" + this.axisKey() + \"Offset\"];\n    const sliderStart = windowOffset + (this.props.invert ? sliderMax : sliderMin);\n    let pixelOffset = position - sliderStart;\n    if (this.props.invert) {\n      pixelOffset = this.state.sliderLength - pixelOffset;\n    }\n    pixelOffset -= this.state.thumbSize / 2;\n    return pixelOffset;\n  } // Snaps the nearest thumb to the value corresponding to `position`\n  // and calls `callback` with that thumb's index.\n  ;\n\n  _proto.forceValueFromPosition = function forceValueFromPosition(position, callback) {\n    const pixelOffset = this.calcOffsetFromPosition(position);\n    const closestIndex = this.getClosestIndex(pixelOffset);\n    const nextValue = trimAlignValue(this.calcValue(pixelOffset), this.props); // Clone this.state.value since we'll modify it temporarily\n    // eslint-disable-next-line zillow/react/no-access-state-in-setstate\n\n    const value = this.state.value.slice();\n    value[closestIndex] = nextValue; // Prevents the slider from shrinking below `props.minDistance`\n\n    for (let i = 0; i < value.length - 1; i += 1) {\n      if (value[i + 1] - value[i] < this.props.minDistance) {\n        return;\n      }\n    }\n    this.fireChangeEvent('onBeforeChange');\n    this.hasMoved = true;\n    this.setState({\n      value\n    }, () => {\n      callback(closestIndex);\n      this.fireChangeEvent('onChange');\n    });\n  } // clear all pending timeouts to avoid error messages after unmounting\n  ;\n\n  _proto.clearPendingResizeTimeouts = function clearPendingResizeTimeouts() {\n    do {\n      const nextTimeout = this.pendingResizeTimeouts.shift();\n      clearTimeout(nextTimeout);\n    } while (this.pendingResizeTimeouts.length);\n  };\n  _proto.start = function start(i, position) {\n    const thumbRef = this[\"thumb\" + i];\n    if (thumbRef) {\n      thumbRef.focus();\n    }\n    const {\n      zIndices\n    } = this.state; // remove wherever the element is\n\n    zIndices.splice(zIndices.indexOf(i), 1); // add to end\n\n    zIndices.push(i);\n    this.setState(prevState => ({\n      startValue: prevState.value[i],\n      startPosition: position !== undefined ? position : prevState.startPosition,\n      index: i,\n      zIndices\n    }));\n  };\n  _proto.moveUpByStep = function moveUpByStep(step) {\n    if (step === void 0) {\n      step = this.props.step;\n    }\n    const oldValue = this.state.value[this.state.index];\n    const newValue = trimAlignValue(oldValue + step, this.props);\n    this.move(Math.min(newValue, this.props.max));\n  };\n  _proto.moveDownByStep = function moveDownByStep(step) {\n    if (step === void 0) {\n      step = this.props.step;\n    }\n    const oldValue = this.state.value[this.state.index];\n    const newValue = trimAlignValue(oldValue - step, this.props);\n    this.move(Math.max(newValue, this.props.min));\n  };\n  _proto.move = function move(newValue) {\n    const {\n      index,\n      value\n    } = this.state;\n    const {\n      length\n    } = value; // Short circuit if the value is not changing\n\n    const oldValue = value[index];\n    if (newValue === oldValue) {\n      return;\n    } // Trigger only before the first movement\n\n    if (!this.hasMoved) {\n      this.fireChangeEvent('onBeforeChange');\n    }\n    this.hasMoved = true; // if \"pearling\" (= thumbs pushing each other) is disabled,\n    // prevent the thumb from getting closer than `minDistance` to the previous or next thumb.\n\n    const {\n      pearling,\n      max,\n      min,\n      minDistance\n    } = this.props;\n    if (!pearling) {\n      if (index > 0) {\n        const valueBefore = value[index - 1];\n        if (newValue < valueBefore + minDistance) {\n          // eslint-disable-next-line no-param-reassign\n          newValue = valueBefore + minDistance;\n        }\n      }\n      if (index < length - 1) {\n        const valueAfter = value[index + 1];\n        if (newValue > valueAfter - minDistance) {\n          // eslint-disable-next-line no-param-reassign\n          newValue = valueAfter - minDistance;\n        }\n      }\n    }\n    value[index] = newValue; // if \"pearling\" is enabled, let the current thumb push the pre- and succeeding thumbs.\n\n    if (pearling && length > 1) {\n      if (newValue > oldValue) {\n        this.pushSucceeding(value, minDistance, index);\n        trimSucceeding(length, value, minDistance, max);\n      } else if (newValue < oldValue) {\n        this.pushPreceding(value, minDistance, index);\n        trimPreceding(length, value, minDistance, min);\n      }\n    } // Normally you would use `shouldComponentUpdate`,\n    // but since the slider is a low-level component,\n    // the extra complexity might be worth the extra performance.\n\n    this.setState({\n      value\n    }, this.fireChangeEvent.bind(this, 'onChange'));\n  };\n  _proto.pushSucceeding = function pushSucceeding(value, minDistance, index) {\n    let i;\n    let padding;\n    for (i = index, padding = value[i] + minDistance; value[i + 1] !== null && padding > value[i + 1]; i += 1, padding = value[i] + minDistance) {\n      // eslint-disable-next-line no-param-reassign\n      value[i + 1] = alignValue(padding, this.props);\n    }\n  };\n  _proto.pushPreceding = function pushPreceding(value, minDistance, index) {\n    for (let i = index, padding = value[i] - minDistance; value[i - 1] !== null && padding < value[i - 1]; i -= 1, padding = value[i] - minDistance) {\n      // eslint-disable-next-line no-param-reassign\n      value[i - 1] = alignValue(padding, this.props);\n    }\n  };\n  _proto.axisKey = function axisKey() {\n    if (this.props.orientation === 'vertical') {\n      return 'Y';\n    } // Defaults to 'horizontal';\n\n    return 'X';\n  };\n  _proto.orthogonalAxisKey = function orthogonalAxisKey() {\n    if (this.props.orientation === 'vertical') {\n      return 'X';\n    } // Defaults to 'horizontal'\n\n    return 'Y';\n  };\n  _proto.posMinKey = function posMinKey() {\n    if (this.props.orientation === 'vertical') {\n      return this.props.invert ? 'bottom' : 'top';\n    } // Defaults to 'horizontal'\n\n    return this.props.invert ? 'right' : 'left';\n  };\n  _proto.posMaxKey = function posMaxKey() {\n    if (this.props.orientation === 'vertical') {\n      return this.props.invert ? 'top' : 'bottom';\n    } // Defaults to 'horizontal'\n\n    return this.props.invert ? 'left' : 'right';\n  };\n  _proto.sizeKey = function sizeKey() {\n    if (this.props.orientation === 'vertical') {\n      return 'clientHeight';\n    } // Defaults to 'horizontal'\n\n    return 'clientWidth';\n  };\n  _proto.fireChangeEvent = function fireChangeEvent(event) {\n    if (this.props[event]) {\n      this.props[event](prepareOutValue(this.state.value), this.state.index);\n    }\n  };\n  _proto.buildThumbStyle = function buildThumbStyle(offset, i) {\n    const style = {\n      position: 'absolute',\n      touchAction: 'none',\n      willChange: this.state.index >= 0 ? this.posMinKey() : undefined,\n      zIndex: this.state.zIndices.indexOf(i) + 1\n    };\n    style[this.posMinKey()] = offset + \"px\";\n    return style;\n  };\n  _proto.buildTrackStyle = function buildTrackStyle(min, max) {\n    const obj = {\n      position: 'absolute',\n      willChange: this.state.index >= 0 ? this.posMinKey() + \",\" + this.posMaxKey() : undefined\n    };\n    obj[this.posMinKey()] = min;\n    obj[this.posMaxKey()] = max;\n    return obj;\n  };\n  _proto.buildMarkStyle = function buildMarkStyle(offset) {\n    var _ref;\n    return _ref = {\n      position: 'absolute'\n    }, _ref[this.posMinKey()] = offset, _ref;\n  };\n  _proto.renderThumbs = function renderThumbs(offset) {\n    const {\n      length\n    } = offset;\n    const styles = [];\n    for (let i = 0; i < length; i += 1) {\n      styles[i] = this.buildThumbStyle(offset[i], i);\n    }\n    const res = [];\n    for (let i = 0; i < length; i += 1) {\n      res[i] = this.renderThumb(styles[i], i);\n    }\n    return res;\n  };\n  _proto.renderTracks = function renderTracks(offset) {\n    const tracks = [];\n    const lastIndex = offset.length - 1;\n    tracks.push(this.renderTrack(0, 0, offset[0]));\n    for (let i = 0; i < lastIndex; i += 1) {\n      tracks.push(this.renderTrack(i + 1, offset[i], offset[i + 1]));\n    }\n    tracks.push(this.renderTrack(lastIndex + 1, offset[lastIndex], this.state.upperBound));\n    return tracks;\n  };\n  _proto.renderMarks = function renderMarks() {\n    let {\n      marks\n    } = this.props;\n    const range = this.props.max - this.props.min + 1;\n    if (typeof marks === 'boolean') {\n      marks = Array.from({\n        length: range\n      }).map((_, key) => key);\n    } else if (typeof marks === 'number') {\n      marks = Array.from({\n        length: range\n      }).map((_, key) => key).filter(key => key % marks === 0);\n    }\n    return marks.map(parseFloat).sort((a, b) => a - b).map(mark => {\n      const offset = this.calcOffset(mark);\n      const props = {\n        key: mark,\n        className: this.props.markClassName,\n        style: this.buildMarkStyle(offset)\n      };\n      return this.props.renderMark(props);\n    });\n  };\n  _proto.render = function render() {\n    const offset = [];\n    const {\n      value\n    } = this.state;\n    const l = value.length;\n    for (let i = 0; i < l; i += 1) {\n      offset[i] = this.calcOffset(value[i], i);\n    }\n    const tracks = this.props.withTracks ? this.renderTracks(offset) : null;\n    const thumbs = this.renderThumbs(offset);\n    const marks = this.props.marks ? this.renderMarks() : null;\n    return /*#__PURE__*/React.createElement('div', {\n      ref: r => {\n        this.slider = r;\n        this.resizeElementRef.current = r;\n      },\n      style: {\n        position: 'relative'\n      },\n      className: this.props.className + (this.props.disabled ? ' disabled' : ''),\n      onMouseDown: this.onSliderMouseDown,\n      onClick: this.onSliderClick\n    }, tracks, thumbs, marks);\n  };\n  return ReactSlider;\n}(React.Component);\nReactSlider.displayName = 'ReactSlider';\nReactSlider.defaultProps = {\n  min: 0,\n  max: 100,\n  step: 1,\n  pageFn: step => step * 10,\n  minDistance: 0,\n  defaultValue: 0,\n  orientation: 'horizontal',\n  className: 'slider',\n  thumbClassName: 'thumb',\n  thumbActiveClassName: 'active',\n  trackClassName: 'track',\n  markClassName: 'mark',\n  withTracks: true,\n  pearling: false,\n  disabled: false,\n  snapDragDisabled: false,\n  invert: false,\n  marks: [],\n  renderThumb: props => /*#__PURE__*/React.createElement(\"div\", _extends({}, props, {\n    __self: ReactSlider,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 353,\n      columnNumber: 31\n    }\n  })),\n  renderTrack: props => /*#__PURE__*/React.createElement(\"div\", _extends({}, props, {\n    __self: ReactSlider,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 354,\n      columnNumber: 31\n    }\n  })),\n  renderMark: props => /*#__PURE__*/React.createElement(\"span\", _extends({}, props, {\n    __self: ReactSlider,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 355,\n      columnNumber: 30\n    }\n  }))\n};\nReactSlider.propTypes = process.env.NODE_ENV !== \"production\" ? {\n  /**\n   * The minimum value of the slider.\n   */\n  min: PropTypes.number,\n  /**\n   * The maximum value of the slider.\n   */\n  max: PropTypes.number,\n  /**\n   * Value to be added or subtracted on each step the slider makes.\n   * Must be greater than zero.\n   * `max - min` should be evenly divisible by the step value.\n   */\n  step: PropTypes.number,\n  /**\n   * The result of the function is the value to be added or subtracted\n   * when the `Page Up` or `Page Down` keys are pressed.\n   *\n   * The current `step` value will be passed as the only argument.\n   * By default, paging will modify `step` by a factor of 10.\n   */\n  pageFn: PropTypes.func,\n  /**\n   * The minimal distance between any pair of thumbs.\n   * Must be positive, but zero means they can sit on top of each other.\n   */\n  minDistance: PropTypes.number,\n  /**\n   * Determines the initial positions of the thumbs and the number of thumbs.\n   *\n   * If a number is passed a slider with one thumb will be rendered.\n   * If an array is passed each value will determine the position of one thumb.\n   * The values in the array must be sorted.\n   */\n  defaultValue: PropTypes.oneOfType([PropTypes.number, PropTypes.arrayOf(PropTypes.number)]),\n  /**\n   * Like `defaultValue` but for\n   * [controlled components](http://facebook.github.io/react/docs/forms.html#controlled-components).\n   */\n  // eslint-disable-next-line zillow/react/require-default-props\n  value: PropTypes.oneOfType([PropTypes.number, PropTypes.arrayOf(PropTypes.number)]),\n  /**\n   * Determines whether the slider moves horizontally (from left to right)\n   * or vertically (from top to bottom).\n   */\n  orientation: PropTypes.oneOf(['horizontal', 'vertical']),\n  /**\n   * The css class set on the slider node.\n   */\n  className: PropTypes.string,\n  /**\n   * The css class set on each thumb node.\n   *\n   * In addition each thumb will receive a numbered css class of the form\n   * `${thumbClassName}-${i}`, e.g. `thumb-0`, `thumb-1`, ...\n   */\n  thumbClassName: PropTypes.string,\n  /**\n   * The css class set on the thumb that is currently being moved.\n   */\n  thumbActiveClassName: PropTypes.string,\n  /**\n   * If `true` tracks between the thumbs will be rendered.\n   */\n  withTracks: PropTypes.bool,\n  /**\n   * The css class set on the tracks between the thumbs.\n   * In addition track fragment will receive a numbered css class of the form\n   * `${trackClassName}-${i}`, e.g. `track-0`, `track-1`, ...\n   */\n  trackClassName: PropTypes.string,\n  /**\n   * If `true` the active thumb will push other thumbs\n   * within the constraints of `min`, `max`, `step` and `minDistance`.\n   */\n  pearling: PropTypes.bool,\n  /**\n   * If `true` the thumbs can't be moved.\n   */\n  disabled: PropTypes.bool,\n  /**\n   * Disables thumb move when clicking the slider track\n   */\n  snapDragDisabled: PropTypes.bool,\n  /**\n   * Inverts the slider.\n   */\n  invert: PropTypes.bool,\n  /**\n   * Shows passed marks on the track, if true it shows all the marks,\n   * if an array of numbers it shows just the passed marks, if a number is passed\n   * it shows just the marks in that steps: like passing 3 shows the marks 3, 6, 9\n   */\n  marks: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.number), PropTypes.bool, PropTypes.number]),\n  /**\n   * The css class set on the marks.\n   */\n  markClassName: PropTypes.string,\n  /**\n   * Callback called before starting to move a thumb. The callback will only be called if the\n   * action will result in a change. The function will be called with two arguments, the first\n   * being the initial value(s) the second being thumb index.\n   */\n  // eslint-disable-next-line max-len\n  // eslint-disable-next-line zillow/react/require-default-props, zillow/react/no-unused-prop-types\n  onBeforeChange: PropTypes.func,\n  /**\n   * Callback called on every value change.\n   * The function will be called with two arguments, the first being the new value(s)\n   * the second being thumb index.\n   */\n  // eslint-disable-next-line max-len\n  // eslint-disable-next-line zillow/react/require-default-props, zillow/react/no-unused-prop-types\n  onChange: PropTypes.func,\n  /**\n   * Callback called only after moving a thumb has ended. The callback will only be called if\n   * the action resulted in a change. The function will be called with two arguments, the\n   * first being the result value(s) the second being thumb index.\n   */\n  // eslint-disable-next-line max-len\n  // eslint-disable-next-line zillow/react/require-default-props, zillow/react/no-unused-prop-types\n  onAfterChange: PropTypes.func,\n  /**\n   * Callback called when the the slider is clicked (thumb or tracks).\n   * Receives the value at the clicked position as argument.\n   */\n  // eslint-disable-next-line zillow/react/require-default-props\n  onSliderClick: PropTypes.func,\n  /**\n   * aria-label for screen-readers to apply to the thumbs.\n   * Use an array for more than one thumb.\n   * The length of the array must match the number of thumbs in the value array.\n   */\n  // eslint-disable-next-line zillow/react/require-default-props\n  ariaLabel: PropTypes.oneOfType([PropTypes.string, PropTypes.arrayOf(PropTypes.string)]),\n  /**\n   * aria-labelledby for screen-readers to apply to the thumbs.\n   * Used when slider rendered with separate label.\n   * Use an array for more than one thumb.\n   * The length of the array must match the number of thumbs in the value array.\n   */\n  // eslint-disable-next-line zillow/react/require-default-props\n  ariaLabelledby: PropTypes.oneOfType([PropTypes.string, PropTypes.arrayOf(PropTypes.string)]),\n  /**\n   * aria-valuetext for screen-readers.\n   * Can be a static string, or a function that returns a string.\n   * The function will be passed a single argument,\n   * an object with the following properties:\n   *\n   *     state => `Value: ${state.value}`\n   *\n   * - `state.index` {`number`} the index of the thumb\n   * - `state.value` {`number` | `array`} the current value state\n   * - `state.valueNow` {`number`} the value of the thumb (i.e. aria-valuenow)\n   */\n  // eslint-disable-next-line zillow/react/require-default-props\n  ariaValuetext: PropTypes.oneOfType([PropTypes.string, PropTypes.func]),\n  /**\n   * Provide a custom render function for the track node.\n   * The render function will be passed two arguments,\n   * an object with props that should be added to your handle node,\n   * and an object with track and slider state:\n   *\n   *     (props, state) => <div {...props} />\n   *\n   * - `props` {`object`} props to be spread into your track node\n   * - `state.index` {`number`} the index of the track\n   * - `state.value` {`number` | `array`} the current value state\n   */\n  renderTrack: PropTypes.func,\n  /**\n   * Provide a custom render function for dynamic thumb content.\n   * The render function will be passed two arguments,\n   * an object with props that should be added to your thumb node,\n   * and an object with thumb and slider state:\n   *\n   *     (props, state) => <div {...props} />\n   *\n   * - `props` {`object`} props to be spread into your thumb node\n   * - `state.index` {`number`} the index of the thumb\n   * - `state.value` {`number` | `array`} the current value state\n   * - `state.valueNow` {`number`} the value of the thumb (i.e. aria-valuenow)\n   */\n  // eslint-disable-next-line zillow/react/require-default-props\n  renderThumb: PropTypes.func,\n  /**\n   * Provide a custom render function for the mark node.\n   * The render function will be passed one argument,\n   * an object with props that should be added to your handle node\n   *\n   *     (props) => <span {...props} />\n   *\n   * - `props` {`object`} props to be spread into your track node\n   */\n  renderMark: PropTypes.func\n} : {};\nvar ReactSlider$1 = ReactSlider;\nexport { ReactSlider$1 as default };","map":{"version":3,"names":["pauseEvent","e","stopPropagation","preventDefault","sanitizeInValue","x","Array","isArray","slice","prepareOutValue","length","trimSucceeding","nextValue","minDistance","max","i","padding","trimPreceding","min","addHandlers","eventMap","Object","keys","forEach","key","document","addEventListener","removeHandlers","removeEventListener","trimAlignValue","val","props","alignValue","trimValue","valModStep","step","alignedValue","Math","abs","parseFloat","toFixed","trimmed","ReactSlider","_React$Component","_props","_this","call","onKeyUp","onEnd","onMouseUp","getMouseEventMap","onTouchEnd","getTouchEventMap","onBlur","setState","index","getKeyDownEventMap","onMouseMove","pending","position","getMousePosition","diffPosition","getDiffPosition","newValue","getValueFromPosition","move","onTouchMove","touches","getTouchPosition","isScrolling","diffMainDir","startPosition","diffScrollDir","onKeyDown","ctrlKey","shiftKey","altKey","metaKey","moveDownByStep","moveUpByStep","pageFn","onSliderMouseDown","disabled","button","snapDragDisabled","forceValueFromPosition","start","onSliderClick","hasMoved","valueAtPos","calcValue","calcOffsetFromPosition","createOnKeyDown","createOnMouseDown","createOnTouchStart","undefined","handleResize","resizeTimeout","window","setTimeout","pendingResizeTimeouts","shift","resize","push","renderThumb","style","className","thumbClassName","state","thumbActiveClassName","r","orientation","value","ariaLabel","ariaLabelledby","valueNow","ariaValuetext","renderTrack","offsetFrom","offsetTo","trackClassName","buildTrackStyle","upperBound","defaultValue","zIndices","resizeObserver","resizeElementRef","React","createRef","sliderLength","_proto","componentDidMount","ResizeObserver","observe","current","getDerivedStateFromProps","map","item","componentDidUpdate","componentWillUnmount","clearPendingResizeTimeouts","disconnect","fireChangeEvent","getValue","getClosestIndex","pixelOffset","minDist","Number","MAX_VALUE","closestIndex","l","offset","calcOffset","dist","axisKey","orthogonalAxisKey","touch","keydown","keyup","focusout","mousemove","mouseup","touchmove","touchend","diffValue","thumbSize","startValue","invert","slider","thumb0","thumb","sizeKey","sliderRect","getBoundingClientRect","sliderSize","sliderMax","posMaxKey","sliderMin","posMinKey","thumbRect","replace","toLowerCase","range","ratio","windowOffset","sliderStart","callback","nextTimeout","clearTimeout","thumbRef","focus","splice","indexOf","prevState","oldValue","pearling","valueBefore","valueAfter","pushSucceeding","pushPreceding","bind","event","buildThumbStyle","touchAction","willChange","zIndex","obj","buildMarkStyle","_ref","renderThumbs","styles","res","renderTracks","tracks","lastIndex","renderMarks","marks","from","_","filter","sort","a","b","mark","markClassName","renderMark","render","withTracks","thumbs","createElement","ref","onMouseDown","onClick","Component","displayName","defaultProps","_extends","__self","__source","fileName","_jsxFileName","lineNumber","columnNumber","propTypes","process","env","NODE_ENV","PropTypes","number","func","oneOfType","arrayOf","oneOf","string","bool","onBeforeChange","onChange","onAfterChange","ReactSlider$1"],"sources":["C:\\Users\\8068programmer\\Documents\\GitHub\\leader-v3\\node_modules\\react-slider\\src\\components\\ReactSlider\\ReactSlider.jsx"],"sourcesContent":["import React from 'react';\nimport PropTypes from 'prop-types';\n\n/**\n * To prevent text selection while dragging.\n * http://stackoverflow.com/questions/5429827/how-can-i-prevent-text-element-selection-with-cursor-drag\n */\nfunction pauseEvent(e) {\n    if (e && e.stopPropagation) {\n        e.stopPropagation();\n    }\n    if (e && e.preventDefault) {\n        e.preventDefault();\n    }\n    return false;\n}\n\nfunction stopPropagation(e) {\n    if (e.stopPropagation) {\n        e.stopPropagation();\n    }\n}\n\nfunction sanitizeInValue(x) {\n    if (x == null) {\n        return [];\n    }\n    return Array.isArray(x) ? x.slice() : [x];\n}\n\nfunction prepareOutValue(x) {\n    return x !== null && x.length === 1 ? x[0] : x.slice();\n}\n\nfunction trimSucceeding(length, nextValue, minDistance, max) {\n    for (let i = 0; i < length; i += 1) {\n        const padding = max - i * minDistance;\n        if (nextValue[length - 1 - i] > padding) {\n            // eslint-disable-next-line no-param-reassign\n            nextValue[length - 1 - i] = padding;\n        }\n    }\n}\n\nfunction trimPreceding(length, nextValue, minDistance, min) {\n    for (let i = 0; i < length; i += 1) {\n        const padding = min + i * minDistance;\n        if (nextValue[i] < padding) {\n            // eslint-disable-next-line no-param-reassign\n            nextValue[i] = padding;\n        }\n    }\n}\n\nfunction addHandlers(eventMap) {\n    Object.keys(eventMap).forEach(key => {\n        if (typeof document !== 'undefined') {\n            document.addEventListener(key, eventMap[key], false);\n        }\n    });\n}\n\nfunction removeHandlers(eventMap) {\n    Object.keys(eventMap).forEach(key => {\n        if (typeof document !== 'undefined') {\n            document.removeEventListener(key, eventMap[key], false);\n        }\n    });\n}\n\nfunction trimAlignValue(val, props) {\n    return alignValue(trimValue(val, props), props);\n}\n\nfunction alignValue(val, props) {\n    const valModStep = (val - props.min) % props.step;\n    let alignedValue = val - valModStep;\n\n    if (Math.abs(valModStep) * 2 >= props.step) {\n        alignedValue += valModStep > 0 ? props.step : -props.step;\n    }\n\n    return parseFloat(alignedValue.toFixed(5));\n}\n\nfunction trimValue(val, props) {\n    let trimmed = val;\n    if (trimmed <= props.min) {\n        trimmed = props.min;\n    }\n    if (trimmed >= props.max) {\n        trimmed = props.max;\n    }\n\n    return trimmed;\n}\n\nclass ReactSlider extends React.Component {\n    static displayName = 'ReactSlider';\n\n    static propTypes = {\n        /**\n         * The minimum value of the slider.\n         */\n        min: PropTypes.number,\n\n        /**\n         * The maximum value of the slider.\n         */\n        max: PropTypes.number,\n\n        /**\n         * Value to be added or subtracted on each step the slider makes.\n         * Must be greater than zero.\n         * `max - min` should be evenly divisible by the step value.\n         */\n        step: PropTypes.number,\n\n        /**\n         * The result of the function is the value to be added or subtracted\n         * when the `Page Up` or `Page Down` keys are pressed.\n         *\n         * The current `step` value will be passed as the only argument.\n         * By default, paging will modify `step` by a factor of 10.\n         */\n        pageFn: PropTypes.func,\n\n        /**\n         * The minimal distance between any pair of thumbs.\n         * Must be positive, but zero means they can sit on top of each other.\n         */\n        minDistance: PropTypes.number,\n\n        /**\n         * Determines the initial positions of the thumbs and the number of thumbs.\n         *\n         * If a number is passed a slider with one thumb will be rendered.\n         * If an array is passed each value will determine the position of one thumb.\n         * The values in the array must be sorted.\n         */\n        defaultValue: PropTypes.oneOfType([PropTypes.number, PropTypes.arrayOf(PropTypes.number)]),\n\n        /**\n         * Like `defaultValue` but for\n         * [controlled components](http://facebook.github.io/react/docs/forms.html#controlled-components).\n         */\n        // eslint-disable-next-line zillow/react/require-default-props\n        value: PropTypes.oneOfType([PropTypes.number, PropTypes.arrayOf(PropTypes.number)]),\n\n        /**\n         * Determines whether the slider moves horizontally (from left to right)\n         * or vertically (from top to bottom).\n         */\n        orientation: PropTypes.oneOf(['horizontal', 'vertical']),\n\n        /**\n         * The css class set on the slider node.\n         */\n        className: PropTypes.string,\n\n        /**\n         * The css class set on each thumb node.\n         *\n         * In addition each thumb will receive a numbered css class of the form\n         * `${thumbClassName}-${i}`, e.g. `thumb-0`, `thumb-1`, ...\n         */\n        thumbClassName: PropTypes.string,\n\n        /**\n         * The css class set on the thumb that is currently being moved.\n         */\n        thumbActiveClassName: PropTypes.string,\n\n        /**\n         * If `true` tracks between the thumbs will be rendered.\n         */\n        withTracks: PropTypes.bool,\n\n        /**\n         * The css class set on the tracks between the thumbs.\n         * In addition track fragment will receive a numbered css class of the form\n         * `${trackClassName}-${i}`, e.g. `track-0`, `track-1`, ...\n         */\n        trackClassName: PropTypes.string,\n\n        /**\n         * If `true` the active thumb will push other thumbs\n         * within the constraints of `min`, `max`, `step` and `minDistance`.\n         */\n        pearling: PropTypes.bool,\n\n        /**\n         * If `true` the thumbs can't be moved.\n         */\n        disabled: PropTypes.bool,\n\n        /**\n         * Disables thumb move when clicking the slider track\n         */\n        snapDragDisabled: PropTypes.bool,\n\n        /**\n         * Inverts the slider.\n         */\n        invert: PropTypes.bool,\n\n        /**\n         * Shows passed marks on the track, if true it shows all the marks,\n         * if an array of numbers it shows just the passed marks, if a number is passed\n         * it shows just the marks in that steps: like passing 3 shows the marks 3, 6, 9\n         */\n        marks: PropTypes.oneOfType([\n            PropTypes.arrayOf(PropTypes.number),\n            PropTypes.bool,\n            PropTypes.number,\n        ]),\n\n        /**\n         * The css class set on the marks.\n         */\n        markClassName: PropTypes.string,\n\n        /**\n         * Callback called before starting to move a thumb. The callback will only be called if the\n         * action will result in a change. The function will be called with two arguments, the first\n         * being the initial value(s) the second being thumb index.\n         */\n        // eslint-disable-next-line max-len\n        // eslint-disable-next-line zillow/react/require-default-props, zillow/react/no-unused-prop-types\n        onBeforeChange: PropTypes.func,\n\n        /**\n         * Callback called on every value change.\n         * The function will be called with two arguments, the first being the new value(s)\n         * the second being thumb index.\n         */\n        // eslint-disable-next-line max-len\n        // eslint-disable-next-line zillow/react/require-default-props, zillow/react/no-unused-prop-types\n        onChange: PropTypes.func,\n\n        /**\n         * Callback called only after moving a thumb has ended. The callback will only be called if\n         * the action resulted in a change. The function will be called with two arguments, the\n         * first being the result value(s) the second being thumb index.\n         */\n        // eslint-disable-next-line max-len\n        // eslint-disable-next-line zillow/react/require-default-props, zillow/react/no-unused-prop-types\n        onAfterChange: PropTypes.func,\n\n        /**\n         * Callback called when the the slider is clicked (thumb or tracks).\n         * Receives the value at the clicked position as argument.\n         */\n        // eslint-disable-next-line zillow/react/require-default-props\n        onSliderClick: PropTypes.func,\n\n        /**\n         * aria-label for screen-readers to apply to the thumbs.\n         * Use an array for more than one thumb.\n         * The length of the array must match the number of thumbs in the value array.\n         */\n        // eslint-disable-next-line zillow/react/require-default-props\n        ariaLabel: PropTypes.oneOfType([PropTypes.string, PropTypes.arrayOf(PropTypes.string)]),\n\n        /**\n         * aria-labelledby for screen-readers to apply to the thumbs.\n         * Used when slider rendered with separate label.\n         * Use an array for more than one thumb.\n         * The length of the array must match the number of thumbs in the value array.\n         */\n        // eslint-disable-next-line zillow/react/require-default-props\n        ariaLabelledby: PropTypes.oneOfType([\n            PropTypes.string,\n            PropTypes.arrayOf(PropTypes.string),\n        ]),\n\n        /**\n         * aria-valuetext for screen-readers.\n         * Can be a static string, or a function that returns a string.\n         * The function will be passed a single argument,\n         * an object with the following properties:\n         *\n         *     state => `Value: ${state.value}`\n         *\n         * - `state.index` {`number`} the index of the thumb\n         * - `state.value` {`number` | `array`} the current value state\n         * - `state.valueNow` {`number`} the value of the thumb (i.e. aria-valuenow)\n         */\n        // eslint-disable-next-line zillow/react/require-default-props\n        ariaValuetext: PropTypes.oneOfType([PropTypes.string, PropTypes.func]),\n\n        /**\n         * Provide a custom render function for the track node.\n         * The render function will be passed two arguments,\n         * an object with props that should be added to your handle node,\n         * and an object with track and slider state:\n         *\n         *     (props, state) => <div {...props} />\n         *\n         * - `props` {`object`} props to be spread into your track node\n         * - `state.index` {`number`} the index of the track\n         * - `state.value` {`number` | `array`} the current value state\n         */\n        renderTrack: PropTypes.func,\n\n        /**\n         * Provide a custom render function for dynamic thumb content.\n         * The render function will be passed two arguments,\n         * an object with props that should be added to your thumb node,\n         * and an object with thumb and slider state:\n         *\n         *     (props, state) => <div {...props} />\n         *\n         * - `props` {`object`} props to be spread into your thumb node\n         * - `state.index` {`number`} the index of the thumb\n         * - `state.value` {`number` | `array`} the current value state\n         * - `state.valueNow` {`number`} the value of the thumb (i.e. aria-valuenow)\n         */\n        // eslint-disable-next-line zillow/react/require-default-props\n        renderThumb: PropTypes.func,\n\n        /**\n         * Provide a custom render function for the mark node.\n         * The render function will be passed one argument,\n         * an object with props that should be added to your handle node\n         *\n         *     (props) => <span {...props} />\n         *\n         * - `props` {`object`} props to be spread into your track node\n         */\n        renderMark: PropTypes.func,\n    };\n\n    static defaultProps = {\n        min: 0,\n        max: 100,\n        step: 1,\n        pageFn: step => step * 10,\n        minDistance: 0,\n        defaultValue: 0,\n        orientation: 'horizontal',\n        className: 'slider',\n        thumbClassName: 'thumb',\n        thumbActiveClassName: 'active',\n        trackClassName: 'track',\n        markClassName: 'mark',\n        withTracks: true,\n        pearling: false,\n        disabled: false,\n        snapDragDisabled: false,\n        invert: false,\n        marks: [],\n        renderThumb: props => <div {...props} />,\n        renderTrack: props => <div {...props} />,\n        renderMark: props => <span {...props} />,\n    };\n\n    constructor(props) {\n        super(props);\n\n        let value = sanitizeInValue(props.value);\n        if (!value.length) {\n            value = sanitizeInValue(props.defaultValue);\n        }\n\n        // array for storing resize timeouts ids\n        this.pendingResizeTimeouts = [];\n\n        const zIndices = [];\n        for (let i = 0; i < value.length; i += 1) {\n            value[i] = trimAlignValue(value[i], props);\n            zIndices.push(i);\n        }\n\n        this.resizeObserver = null;\n        this.resizeElementRef = React.createRef();\n\n        this.state = {\n            index: -1,\n            upperBound: 0,\n            sliderLength: 0,\n            value,\n            zIndices,\n        };\n    }\n\n    componentDidMount() {\n        if (typeof window !== 'undefined') {\n            this.resizeObserver = new ResizeObserver(this.handleResize);\n            this.resizeObserver.observe(this.resizeElementRef.current);\n            this.resize();\n        }\n    }\n\n    // Keep the internal `value` consistent with an outside `value` if present.\n    // This basically allows the slider to be a controlled component.\n    static getDerivedStateFromProps(props, state) {\n        const value = sanitizeInValue(props.value);\n        if (!value.length) {\n            return null;\n        }\n\n        // Do not allow controlled upates to happen while we have pending updates\n        if (state.pending) {\n            return null;\n        }\n\n        return {\n            value: value.map(item => trimAlignValue(item, props)),\n        };\n    }\n\n    componentDidUpdate() {\n        // If an upperBound has not yet been determined (due to the component being hidden\n        // during the mount event, or during the last resize), then calculate it now\n        if (this.state.upperBound === 0) {\n            this.resize();\n        }\n    }\n\n    componentWillUnmount() {\n        this.clearPendingResizeTimeouts();\n        if (this.resizeObserver) {\n            this.resizeObserver.disconnect();\n        }\n    }\n\n    onKeyUp = () => {\n        this.onEnd();\n    };\n\n    onMouseUp = () => {\n        this.onEnd(this.getMouseEventMap());\n    };\n\n    onTouchEnd = () => {\n        this.onEnd(this.getTouchEventMap());\n    };\n\n    onBlur = () => {\n        this.setState({ index: -1 }, this.onEnd(this.getKeyDownEventMap()));\n    };\n\n    onEnd(eventMap) {\n        if (eventMap) {\n            removeHandlers(eventMap);\n        }\n        if (this.hasMoved) {\n            this.fireChangeEvent('onAfterChange');\n        }\n\n        // Allow controlled updates to continue\n        this.setState({ pending: false });\n\n        this.hasMoved = false;\n    }\n\n    onMouseMove = e => {\n        // Prevent controlled updates from happening while mouse is moving\n        this.setState({ pending: true });\n\n        const position = this.getMousePosition(e);\n        const diffPosition = this.getDiffPosition(position[0]);\n        const newValue = this.getValueFromPosition(diffPosition);\n        this.move(newValue);\n    };\n\n    onTouchMove = e => {\n        if (e.touches.length > 1) {\n            return;\n        }\n\n        // Prevent controlled updates from happending while touch is moving\n        this.setState({ pending: true });\n\n        const position = this.getTouchPosition(e);\n\n        if (typeof this.isScrolling === 'undefined') {\n            const diffMainDir = position[0] - this.startPosition[0];\n            const diffScrollDir = position[1] - this.startPosition[1];\n            this.isScrolling = Math.abs(diffScrollDir) > Math.abs(diffMainDir);\n        }\n\n        if (this.isScrolling) {\n            this.setState({ index: -1 });\n            return;\n        }\n\n        const diffPosition = this.getDiffPosition(position[0]);\n        const newValue = this.getValueFromPosition(diffPosition);\n\n        this.move(newValue);\n    };\n\n    onKeyDown = e => {\n        if (e.ctrlKey || e.shiftKey || e.altKey || e.metaKey) {\n            return;\n        }\n\n        // Prevent controlled updates from happening while a key is pressed\n        this.setState({ pending: true });\n\n        switch (e.key) {\n            case 'ArrowLeft':\n            case 'ArrowDown':\n            case 'Left':\n            case 'Down':\n                e.preventDefault();\n                this.moveDownByStep();\n                break;\n            case 'ArrowRight':\n            case 'ArrowUp':\n            case 'Right':\n            case 'Up':\n                e.preventDefault();\n                this.moveUpByStep();\n                break;\n            case 'Home':\n                e.preventDefault();\n                this.move(this.props.min);\n                break;\n            case 'End':\n                e.preventDefault();\n                this.move(this.props.max);\n                break;\n            case 'PageDown':\n                e.preventDefault();\n                this.moveDownByStep(this.props.pageFn(this.props.step));\n                break;\n            case 'PageUp':\n                e.preventDefault();\n                this.moveUpByStep(this.props.pageFn(this.props.step));\n                break;\n            default:\n        }\n    };\n\n    onSliderMouseDown = e => {\n        // do nothing if disabled or right click\n        if (this.props.disabled || e.button === 2) {\n            return;\n        }\n\n        // Prevent controlled updates from happening while mouse is moving\n        this.setState({ pending: true });\n\n        if (!this.props.snapDragDisabled) {\n            const position = this.getMousePosition(e);\n            this.forceValueFromPosition(position[0], i => {\n                this.start(i, position[0]);\n                addHandlers(this.getMouseEventMap());\n            });\n        }\n\n        pauseEvent(e);\n    };\n\n    onSliderClick = e => {\n        if (this.props.disabled) {\n            return;\n        }\n\n        if (this.props.onSliderClick && !this.hasMoved) {\n            const position = this.getMousePosition(e);\n            const valueAtPos = trimAlignValue(\n                this.calcValue(this.calcOffsetFromPosition(position[0])),\n                this.props\n            );\n            this.props.onSliderClick(valueAtPos);\n        }\n    };\n\n    getValue() {\n        return prepareOutValue(this.state.value);\n    }\n\n    getClosestIndex(pixelOffset) {\n        let minDist = Number.MAX_VALUE;\n        let closestIndex = -1;\n\n        const { value } = this.state;\n        const l = value.length;\n\n        for (let i = 0; i < l; i += 1) {\n            const offset = this.calcOffset(value[i]);\n            const dist = Math.abs(pixelOffset - offset);\n            if (dist < minDist) {\n                minDist = dist;\n                closestIndex = i;\n            }\n        }\n\n        return closestIndex;\n    }\n\n    getMousePosition(e) {\n        return [e[`page${this.axisKey()}`], e[`page${this.orthogonalAxisKey()}`]];\n    }\n\n    getTouchPosition(e) {\n        const touch = e.touches[0];\n        return [touch[`page${this.axisKey()}`], touch[`page${this.orthogonalAxisKey()}`]];\n    }\n\n    getKeyDownEventMap() {\n        return {\n            keydown: this.onKeyDown,\n            keyup: this.onKeyUp,\n            focusout: this.onBlur,\n        };\n    }\n\n    getMouseEventMap() {\n        return {\n            mousemove: this.onMouseMove,\n            mouseup: this.onMouseUp,\n        };\n    }\n\n    getTouchEventMap() {\n        return {\n            touchmove: this.onTouchMove,\n            touchend: this.onTouchEnd,\n        };\n    }\n\n    getValueFromPosition(position) {\n        const diffValue =\n            (position / (this.state.sliderLength - this.state.thumbSize)) *\n            (this.props.max - this.props.min);\n        return trimAlignValue(this.state.startValue + diffValue, this.props);\n    }\n\n    getDiffPosition(position) {\n        let diffPosition = position - this.state.startPosition;\n        if (this.props.invert) {\n            diffPosition *= -1;\n        }\n        return diffPosition;\n    }\n\n    // create the `keydown` handler for the i-th thumb\n    createOnKeyDown = i => e => {\n        if (this.props.disabled) {\n            return;\n        }\n        this.start(i);\n        addHandlers(this.getKeyDownEventMap());\n        pauseEvent(e);\n    };\n\n    // create the `mousedown` handler for the i-th thumb\n    createOnMouseDown = i => e => {\n        // do nothing if disabled or right click\n        if (this.props.disabled || e.button === 2) {\n            return;\n        }\n\n        // Prevent controlled updates from happending while mouse is moving\n        this.setState({ pending: true });\n\n        const position = this.getMousePosition(e);\n        this.start(i, position[0]);\n        addHandlers(this.getMouseEventMap());\n        pauseEvent(e);\n    };\n\n    // create the `touchstart` handler for the i-th thumb\n    createOnTouchStart = i => e => {\n        if (this.props.disabled || e.touches.length > 1) {\n            return;\n        }\n\n        // Prevent controlled updates from happending while touch is moving\n        this.setState({ pending: true });\n\n        const position = this.getTouchPosition(e);\n        this.startPosition = position;\n        // don't know yet if the user is trying to scroll\n        this.isScrolling = undefined;\n        this.start(i, position[0]);\n        addHandlers(this.getTouchEventMap());\n        stopPropagation(e);\n    };\n\n    handleResize = () => {\n        // setTimeout of 0 gives element enough time to have assumed its new size if\n        // it is being resized\n        const resizeTimeout = window.setTimeout(() => {\n            // drop this timeout from pendingResizeTimeouts to reduce memory usage\n            this.pendingResizeTimeouts.shift();\n            this.resize();\n        }, 0);\n\n        this.pendingResizeTimeouts.push(resizeTimeout);\n    };\n\n    resize() {\n        const { slider, thumb0: thumb } = this;\n        if (!slider || !thumb) {\n            return;\n        }\n\n        const sizeKey = this.sizeKey();\n\n        // For the slider size, we want to use the client width/height, excluding any borders\n        const sliderRect = slider.getBoundingClientRect();\n        const sliderSize = slider[sizeKey];\n        const sliderMax = sliderRect[this.posMaxKey()];\n        const sliderMin = sliderRect[this.posMinKey()];\n\n        // For the thumb size, we want to use the outer width/height, including any borders\n        const thumbRect = thumb.getBoundingClientRect();\n        const thumbSize = thumbRect[sizeKey.replace('client', '').toLowerCase()];\n\n        const upperBound = sliderSize - thumbSize;\n        const sliderLength = Math.abs(sliderMax - sliderMin);\n\n        if (\n            this.state.upperBound !== upperBound ||\n            this.state.sliderLength !== sliderLength ||\n            this.state.thumbSize !== thumbSize\n        ) {\n            this.setState({\n                upperBound,\n                sliderLength,\n                thumbSize,\n            });\n        }\n    }\n\n    // calculates the offset of a thumb in pixels based on its value.\n    calcOffset(value) {\n        const range = this.props.max - this.props.min;\n        if (range === 0) {\n            return 0;\n        }\n        const ratio = (value - this.props.min) / range;\n        return ratio * this.state.upperBound;\n    }\n\n    // calculates the value corresponding to a given pixel offset, i.e. the inverse of `calcOffset`.\n    calcValue(offset) {\n        const ratio = offset / this.state.upperBound;\n        return ratio * (this.props.max - this.props.min) + this.props.min;\n    }\n\n    calcOffsetFromPosition(position) {\n        const { slider } = this;\n\n        const sliderRect = slider.getBoundingClientRect();\n        const sliderMax = sliderRect[this.posMaxKey()];\n        const sliderMin = sliderRect[this.posMinKey()];\n\n        // The `position` value passed in is the mouse position based on the window height.\n        // The slider bounding rect is based on the viewport, so we must add the window scroll\n        // offset to normalize the values.\n        const windowOffset = window[`page${this.axisKey()}Offset`];\n        const sliderStart = windowOffset + (this.props.invert ? sliderMax : sliderMin);\n\n        let pixelOffset = position - sliderStart;\n        if (this.props.invert) {\n            pixelOffset = this.state.sliderLength - pixelOffset;\n        }\n        pixelOffset -= this.state.thumbSize / 2;\n        return pixelOffset;\n    }\n\n    // Snaps the nearest thumb to the value corresponding to `position`\n    // and calls `callback` with that thumb's index.\n    forceValueFromPosition(position, callback) {\n        const pixelOffset = this.calcOffsetFromPosition(position);\n        const closestIndex = this.getClosestIndex(pixelOffset);\n        const nextValue = trimAlignValue(this.calcValue(pixelOffset), this.props);\n\n        // Clone this.state.value since we'll modify it temporarily\n        // eslint-disable-next-line zillow/react/no-access-state-in-setstate\n        const value = this.state.value.slice();\n        value[closestIndex] = nextValue;\n\n        // Prevents the slider from shrinking below `props.minDistance`\n        for (let i = 0; i < value.length - 1; i += 1) {\n            if (value[i + 1] - value[i] < this.props.minDistance) {\n                return;\n            }\n        }\n\n        this.fireChangeEvent('onBeforeChange');\n        this.hasMoved = true;\n        this.setState({ value }, () => {\n            callback(closestIndex);\n            this.fireChangeEvent('onChange');\n        });\n    }\n\n    // clear all pending timeouts to avoid error messages after unmounting\n    clearPendingResizeTimeouts() {\n        do {\n            const nextTimeout = this.pendingResizeTimeouts.shift();\n\n            clearTimeout(nextTimeout);\n        } while (this.pendingResizeTimeouts.length);\n    }\n\n    start(i, position) {\n        const thumbRef = this[`thumb${i}`];\n        if (thumbRef) {\n            thumbRef.focus();\n        }\n\n        const { zIndices } = this.state;\n        // remove wherever the element is\n        zIndices.splice(zIndices.indexOf(i), 1);\n        // add to end\n        zIndices.push(i);\n\n        this.setState(prevState => ({\n            startValue: prevState.value[i],\n            startPosition: position !== undefined ? position : prevState.startPosition,\n            index: i,\n            zIndices,\n        }));\n    }\n\n    moveUpByStep(step = this.props.step) {\n        const oldValue = this.state.value[this.state.index];\n        const newValue = trimAlignValue(oldValue + step, this.props);\n        this.move(Math.min(newValue, this.props.max));\n    }\n\n    moveDownByStep(step = this.props.step) {\n        const oldValue = this.state.value[this.state.index];\n        const newValue = trimAlignValue(oldValue - step, this.props);\n        this.move(Math.max(newValue, this.props.min));\n    }\n\n    move(newValue) {\n        const { index, value } = this.state;\n        const { length } = value;\n\n        // Short circuit if the value is not changing\n        const oldValue = value[index];\n        if (newValue === oldValue) {\n            return;\n        }\n\n        // Trigger only before the first movement\n        if (!this.hasMoved) {\n            this.fireChangeEvent('onBeforeChange');\n        }\n        this.hasMoved = true;\n\n        // if \"pearling\" (= thumbs pushing each other) is disabled,\n        // prevent the thumb from getting closer than `minDistance` to the previous or next thumb.\n        const { pearling, max, min, minDistance } = this.props;\n        if (!pearling) {\n            if (index > 0) {\n                const valueBefore = value[index - 1];\n                if (newValue < valueBefore + minDistance) {\n                    // eslint-disable-next-line no-param-reassign\n                    newValue = valueBefore + minDistance;\n                }\n            }\n\n            if (index < length - 1) {\n                const valueAfter = value[index + 1];\n                if (newValue > valueAfter - minDistance) {\n                    // eslint-disable-next-line no-param-reassign\n                    newValue = valueAfter - minDistance;\n                }\n            }\n        }\n\n        value[index] = newValue;\n\n        // if \"pearling\" is enabled, let the current thumb push the pre- and succeeding thumbs.\n        if (pearling && length > 1) {\n            if (newValue > oldValue) {\n                this.pushSucceeding(value, minDistance, index);\n                trimSucceeding(length, value, minDistance, max);\n            } else if (newValue < oldValue) {\n                this.pushPreceding(value, minDistance, index);\n                trimPreceding(length, value, minDistance, min);\n            }\n        }\n\n        // Normally you would use `shouldComponentUpdate`,\n        // but since the slider is a low-level component,\n        // the extra complexity might be worth the extra performance.\n        this.setState({ value }, this.fireChangeEvent.bind(this, 'onChange'));\n    }\n\n    pushSucceeding(value, minDistance, index) {\n        let i;\n        let padding;\n        for (\n            i = index, padding = value[i] + minDistance;\n            value[i + 1] !== null && padding > value[i + 1];\n            i += 1, padding = value[i] + minDistance\n        ) {\n            // eslint-disable-next-line no-param-reassign\n            value[i + 1] = alignValue(padding, this.props);\n        }\n    }\n\n    pushPreceding(value, minDistance, index) {\n        for (\n            let i = index, padding = value[i] - minDistance;\n            value[i - 1] !== null && padding < value[i - 1];\n            i -= 1, padding = value[i] - minDistance\n        ) {\n            // eslint-disable-next-line no-param-reassign\n            value[i - 1] = alignValue(padding, this.props);\n        }\n    }\n\n    axisKey() {\n        if (this.props.orientation === 'vertical') {\n            return 'Y';\n        }\n        // Defaults to 'horizontal';\n        return 'X';\n    }\n\n    orthogonalAxisKey() {\n        if (this.props.orientation === 'vertical') {\n            return 'X';\n        }\n        // Defaults to 'horizontal'\n        return 'Y';\n    }\n\n    posMinKey() {\n        if (this.props.orientation === 'vertical') {\n            return this.props.invert ? 'bottom' : 'top';\n        }\n        // Defaults to 'horizontal'\n        return this.props.invert ? 'right' : 'left';\n    }\n\n    posMaxKey() {\n        if (this.props.orientation === 'vertical') {\n            return this.props.invert ? 'top' : 'bottom';\n        }\n        // Defaults to 'horizontal'\n        return this.props.invert ? 'left' : 'right';\n    }\n\n    sizeKey() {\n        if (this.props.orientation === 'vertical') {\n            return 'clientHeight';\n        }\n        // Defaults to 'horizontal'\n        return 'clientWidth';\n    }\n\n    fireChangeEvent(event) {\n        if (this.props[event]) {\n            this.props[event](prepareOutValue(this.state.value), this.state.index);\n        }\n    }\n\n    buildThumbStyle(offset, i) {\n        const style = {\n            position: 'absolute',\n            touchAction: 'none',\n            willChange: this.state.index >= 0 ? this.posMinKey() : undefined,\n            zIndex: this.state.zIndices.indexOf(i) + 1,\n        };\n        style[this.posMinKey()] = `${offset}px`;\n        return style;\n    }\n\n    buildTrackStyle(min, max) {\n        const obj = {\n            position: 'absolute',\n            willChange:\n                this.state.index >= 0 ? `${this.posMinKey()},${this.posMaxKey()}` : undefined,\n        };\n        obj[this.posMinKey()] = min;\n        obj[this.posMaxKey()] = max;\n        return obj;\n    }\n\n    buildMarkStyle(offset) {\n        return {\n            position: 'absolute',\n            [this.posMinKey()]: offset,\n        };\n    }\n\n    renderThumb = (style, i) => {\n        const className = `${this.props.thumbClassName} ${this.props.thumbClassName}-${i} ${\n            this.state.index === i ? this.props.thumbActiveClassName : ''\n        }`;\n\n        const props = {\n            'ref': r => {\n                this[`thumb${i}`] = r;\n            },\n            'key': `${this.props.thumbClassName}-${i}`,\n            className,\n            style,\n            'onMouseDown': this.createOnMouseDown(i),\n            'onTouchStart': this.createOnTouchStart(i),\n            'onFocus': this.createOnKeyDown(i),\n            'tabIndex': 0,\n            'role': 'slider',\n            'aria-orientation': this.props.orientation,\n            'aria-valuenow': this.state.value[i],\n            'aria-valuemin': this.props.min,\n            'aria-valuemax': this.props.max,\n            'aria-label': Array.isArray(this.props.ariaLabel)\n                ? this.props.ariaLabel[i]\n                : this.props.ariaLabel,\n            'aria-labelledby': Array.isArray(this.props.ariaLabelledby)\n                ? this.props.ariaLabelledby[i]\n                : this.props.ariaLabelledby,\n        };\n\n        const state = {\n            index: i,\n            value: prepareOutValue(this.state.value),\n            valueNow: this.state.value[i],\n        };\n\n        if (this.props.ariaValuetext) {\n            props['aria-valuetext'] =\n                typeof this.props.ariaValuetext === 'string'\n                    ? this.props.ariaValuetext\n                    : this.props.ariaValuetext(state);\n        }\n\n        return this.props.renderThumb(props, state);\n    };\n\n    renderThumbs(offset) {\n        const { length } = offset;\n\n        const styles = [];\n        for (let i = 0; i < length; i += 1) {\n            styles[i] = this.buildThumbStyle(offset[i], i);\n        }\n\n        const res = [];\n        for (let i = 0; i < length; i += 1) {\n            res[i] = this.renderThumb(styles[i], i);\n        }\n        return res;\n    }\n\n    renderTrack = (i, offsetFrom, offsetTo) => {\n        const props = {\n            key: `${this.props.trackClassName}-${i}`,\n            className: `${this.props.trackClassName} ${this.props.trackClassName}-${i}`,\n            style: this.buildTrackStyle(offsetFrom, this.state.upperBound - offsetTo),\n        };\n        const state = {\n            index: i,\n            value: prepareOutValue(this.state.value),\n        };\n        return this.props.renderTrack(props, state);\n    };\n\n    renderTracks(offset) {\n        const tracks = [];\n        const lastIndex = offset.length - 1;\n\n        tracks.push(this.renderTrack(0, 0, offset[0]));\n\n        for (let i = 0; i < lastIndex; i += 1) {\n            tracks.push(this.renderTrack(i + 1, offset[i], offset[i + 1]));\n        }\n\n        tracks.push(this.renderTrack(lastIndex + 1, offset[lastIndex], this.state.upperBound));\n\n        return tracks;\n    }\n\n    renderMarks() {\n        let { marks } = this.props;\n\n        const range = this.props.max - this.props.min + 1;\n\n        if (typeof marks === 'boolean') {\n            marks = Array.from({ length: range }).map((_, key) => key);\n        } else if (typeof marks === 'number') {\n            marks = Array.from({ length: range })\n                .map((_, key) => key)\n                .filter(key => key % marks === 0);\n        }\n\n        return marks\n            .map(parseFloat)\n            .sort((a, b) => a - b)\n            .map(mark => {\n                const offset = this.calcOffset(mark);\n\n                const props = {\n                    key: mark,\n                    className: this.props.markClassName,\n                    style: this.buildMarkStyle(offset),\n                };\n\n                return this.props.renderMark(props);\n            });\n    }\n\n    render() {\n        const offset = [];\n        const { value } = this.state;\n        const l = value.length;\n        for (let i = 0; i < l; i += 1) {\n            offset[i] = this.calcOffset(value[i], i);\n        }\n\n        const tracks = this.props.withTracks ? this.renderTracks(offset) : null;\n        const thumbs = this.renderThumbs(offset);\n        const marks = this.props.marks ? this.renderMarks() : null;\n\n        return React.createElement(\n            'div',\n            {\n                ref: r => {\n                    this.slider = r;\n                    this.resizeElementRef.current = r;\n                },\n                style: { position: 'relative' },\n                className: this.props.className + (this.props.disabled ? ' disabled' : ''),\n                onMouseDown: this.onSliderMouseDown,\n                onClick: this.onSliderClick,\n            },\n            tracks,\n            thumbs,\n            marks\n        );\n    }\n}\n\nexport default ReactSlider;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}